[
  {
    "objectID": "summarize.html#pipe-operator",
    "href": "summarize.html#pipe-operator",
    "title": "Summarize",
    "section": "Pipe Operator (%>%)",
    "text": "Pipe Operator (%>%)\nBefore diving into the tidyverse functions that allow for summarization and group-wise operations, let’s talk about the pipe operator (%>%). The pipe is from the magrittr package and allows chaining together multiple functions without needing to create separate objects at each step as you would have to without the pipe.\n\n%>% Example: Using the Pipe\n\n\n\n\n\n\nExample\n\n\n\nAs in the other chapters, let’s use the “penguins” data object found in the palmerpenguins package. Let’s say we want to keep only specimens that have a measurement for both bill length and bill depth and then remove the flipper and body mass columns.\nWithout the pipe–but still using other tidyverse functions–we could go about this like this:\n\n# Filter out the NAs\npenguins_v2 <- dplyr::filter(.data = penguins,\n                              !is.na(bill_length_mm) & !is.na(bill_depth_mm))\n\n# Now strip away the columns we don't want\npenguins_v3 <- dplyr::select(.data = penguins_v2, \n                             -flipper_length_mm, -body_mass_g)\n\n# And we can look at our final product with `base::head`\nhead(penguins_v3)\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm sex     year\n  <fct>   <fct>              <dbl>         <dbl> <fct>  <int>\n1 Adelie  Torgersen           39.1          18.7 male    2007\n2 Adelie  Torgersen           39.5          17.4 female  2007\n3 Adelie  Torgersen           40.3          18   female  2007\n4 Adelie  Torgersen           36.7          19.3 female  2007\n5 Adelie  Torgersen           39.3          20.6 male    2007\n6 Adelie  Torgersen           38.9          17.8 female  2007\n\n\nUsing the pipe though we can simplify this code dramatically! Note that each of the following lines must end with the %>% so that R knows there are more lines to consider.\n\n# We begin with the name of the data object\npenguins %>%\n  # Then we can filter the data\n  dplyr::filter(!is.na(bill_length_mm) & !is.na(bill_depth_mm)) %>%\n  # And strip away the columns we don't want\n  dplyr::select(-flipper_length_mm, -body_mass_g) %>%\n  # And we can even include the `head` argument to see our progress\n  head()\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm sex     year\n  <fct>   <fct>              <dbl>         <dbl> <fct>  <int>\n1 Adelie  Torgersen           39.1          18.7 male    2007\n2 Adelie  Torgersen           39.5          17.4 female  2007\n3 Adelie  Torgersen           40.3          18   female  2007\n4 Adelie  Torgersen           36.7          19.3 female  2007\n5 Adelie  Torgersen           39.3          20.6 male    2007\n6 Adelie  Torgersen           38.9          17.8 female  2007\n\n\nNote that using the pipe allows each line to inherit the data provided by the previous line.\n\n\n\n\nChallenge: %>%\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing pipes, filter the data to only include male penguins, select only the columns for species, island, and body mass, and filter out any rows with NA for body mass.\n\n\n\n\nAside: Fun History of Why %>% is a “Pipe”\nThe Belgian painter René Magritte famously created a painting titled “The Treachery of Images” featuring a depiction of a smoking pipe above the words “Cest ci n’est pas une pipe” (French for “This is not a pipe”). Magritte’s point was about how the depiction of a thing is not equal to thing itself. The magrittr package takes its name from the painter because it also includes a pipe that functions slightly differently from a command line pipe and uses different characters. Just like Magritte’s pipe, %>% both is and isn’t a pipe!"
  },
  {
    "objectID": "summarize.html#group-wise-summarizing",
    "href": "summarize.html#group-wise-summarizing",
    "title": "Summarize",
    "section": "Group-Wise Summarizing",
    "text": "Group-Wise Summarizing\nNow that we’ve covered the %>% operator we can use it to do group-wise summarization! Technically this summarization does not require the pipe but it does inherently have two steps and thus benefits from using the pipe to chain together those technically separate instructions.\nTo summarize by groups we first define our groups using dplyr’s group_by function and then summarize using summarize (also from dplyr). summarize does require you to specify what calculations you want to perform within your groups though it uses similar syntax to dplyr’s mutate function.\n\nDespite the similarity in syntax between summarize and mutate there are a few crucial differences:\n\nsummarize returns only a single row per group while mutate returns as many rows as are in the original dataframe\nsummarize will automatically remove any columns that aren’t either (1) included in group_by or (2) created by summarize. mutate cannot remove columns so it only creates whatever you tell it to.\n\n\ngroup_by + summarize Example: Summarize within Groups\n\n\n\n\n\n\nExample\n\n\n\nLet’s say we want to find some summary values for body mass of each species of penguin on each island. To accomplish this we can do the following:\n\n# Begin with the data and a pipe\npenguins %>%\n  # Group by the desired column names\n  dplyr::group_by(species, island) %>%\n  # And summarize in the way we desire\n  dplyr::summarize(\n    # Get average body mass\n    mean_mass_g = mean(body_mass_g, na.rm = TRUE),\n    # Get the standard deviation\n    sd_mass = sd(body_mass_g, na.rm = TRUE),\n    # Count the number of individual penguins of each species at each island\n    n_mass = dplyr::n(),\n    # Calculate standard error from SD divided by count\n    se_mass = sd_mass / sqrt(n_mass) )\n\n# A tibble: 5 × 6\n# Groups:   species [3]\n  species   island    mean_mass_g sd_mass n_mass se_mass\n  <fct>     <fct>           <dbl>   <dbl>  <int>   <dbl>\n1 Adelie    Biscoe          3710.    488.     44    73.5\n2 Adelie    Dream           3688.    455.     56    60.8\n3 Adelie    Torgersen       3706.    445.     52    61.7\n4 Chinstrap Dream           3733.    384.     68    46.6\n5 Gentoo    Biscoe          5076.    504.    124    45.3\n\n\nYou can see that we also invoked the n function from dplyr to return the size of each group. This function reads any groups created by group_by and returns the count of rows in the dataframe for each group level.\n\n\n\n\nChallenge: summarize\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing what we’ve covered so far, find the average flipper length in each year (regardless of any other grouping variable)."
  },
  {
    "objectID": "summarize.html#grouping-cautionary-note",
    "href": "summarize.html#grouping-cautionary-note",
    "title": "Summarize",
    "section": "Grouping Cautionary Note",
    "text": "Grouping Cautionary Note\ngroup_by can be extremely useful in summarizing a dataframe or creating a new column without losing rows but you need to be careful. Objects created with group_by “remember” their groups until you change the groups or use the function ungroup from dplyr.\nLook at how the output of a grouped data object tells you the number of groups in the output (see beneath this code chunk).\n\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n())\n\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nThis means that all future uses of that pipe will continue to use the grouping established to create the “penguins_count” column. We can stop this by doing the same pipe, but adding ungroup after we’re done using the grouping established by group_by.\n\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n()) %>%\n  dplyr::ungroup()\n\n# A tibble: 5 × 3\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nSee? We calculated with our desired groups but then dropped the grouping structure once we were finished with them. Note also that if you use group_by and do some calculation then re-group by something else by using group_by again, the second use of group_by will not be affected by the first. This means that you only need one ungroup per pipe."
  },
  {
    "objectID": "wrangle.html#what-are-tidy-data",
    "href": "wrangle.html#what-are-tidy-data",
    "title": "Wrangle",
    "section": "What are Tidy Data?",
    "text": "What are Tidy Data?\nWhat are some common things you like to do with your data? Maybe remove rows or columns, do calculations and add new columns? This is called data wrangling. The data we get to work with are rarely, if ever, in the format we need to do our analyses. dplyr and tidyr are two R packages from the tidyverse that provide a fairly complete and extremely powerful set of functions for us to do virtually all needed wrangling quickly. Here we introduce some commonly used functions from these two packages."
  },
  {
    "objectID": "wrangle.html#selecting-columns",
    "href": "wrangle.html#selecting-columns",
    "title": "Wrangle",
    "section": "Selecting columns",
    "text": "Selecting columns\nTo start off, how do we do a fundamental action like selecting the columns we want? dplyr’s select function provides us with a straightforward way to do just that. We only need to provide the column names!\n\n\nselect Example: Including & Excluding\n\n\n\n\n\n\nExample\n\n\n\nTo select only the species, island, and body_mass_g columns, we can use the following code:\n\n# Provide the name of the data and then the columns that you want!\npenguins_selected <- dplyr::select(.data = penguins, species, island, body_mass_g)\n\n# Look at the product\nhead(penguins_selected)\n\n# A tibble: 6 × 3\n  species island    body_mass_g\n  <fct>   <fct>           <int>\n1 Adelie  Torgersen        3750\n2 Adelie  Torgersen        3800\n3 Adelie  Torgersen        3250\n4 Adelie  Torgersen          NA\n5 Adelie  Torgersen        3450\n6 Adelie  Torgersen        3650\n\n\nIf we want to remove specific columns, we can use the - operator.\n\n# Put a \"-\" in front of each column you would like to remove from your dataframe\npenguins_selected <- dplyr::select(.data = penguins, -flipper_length_mm, -sex)\n\n# Look at the product\nhead(penguins_selected)\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm body_mass_g  year\n  <fct>   <fct>              <dbl>         <dbl>       <int> <int>\n1 Adelie  Torgersen           39.1          18.7        3750  2007\n2 Adelie  Torgersen           39.5          17.4        3800  2007\n3 Adelie  Torgersen           40.3          18          3250  2007\n4 Adelie  Torgersen           NA            NA            NA  2007\n5 Adelie  Torgersen           36.7          19.3        3450  2007\n6 Adelie  Torgersen           39.3          20.6        3650  2007\n\n\n\n\n\n\nselect Example: Selecting with Helper Functions\n\n\n\n\n\n\nExample\n\n\n\nIf we want to select the columns that contain length measurements, we can manually type bill_length_mm and flipper_length_mm, but there’s actually an easier way using the contains function, also from the dplyr package. Enter a string that matches what you’re looking for among the column names.\n\n# Enter a matching string inside of a `select` call\npenguins_selected <- dplyr::select(.data = penguins, dplyr::contains(\"length\"))\n\n# Look at the product\nhead(penguins_selected)\n\n# A tibble: 6 × 2\n  bill_length_mm flipper_length_mm\n           <dbl>             <int>\n1           39.1               181\n2           39.5               186\n3           40.3               195\n4           NA                  NA\n5           36.7               193\n6           39.3               190\n\n\n\n\n\n\nselect Example: Selecting a Range of Columns\n\n\n\n\n\n\nExample\n\n\n\nNow what if we wanted all the columns from the first column species to the sixth column body_mass_g? We can use a colon, :, between the first (leftmost) and last (rightmost) columns in the range that we want to include.\n\n# Use a colon to indicate a range of columns you want to select\npenguins_selected <- dplyr::select(.data = penguins, species:body_mass_g)\n\n# Look at the product\nhead(penguins_selected)\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n\n\nConveniently selecting a range of columns can be especially useful when you have a big dataframe and don’t want to exhaustively list every column by name."
  },
  {
    "objectID": "wrangle.html#subsetting-rows",
    "href": "wrangle.html#subsetting-rows",
    "title": "Wrangle",
    "section": "Subsetting rows",
    "text": "Subsetting rows\nInstead of selecting certain columns, how can we get a subset of rows that meet certain conditions? For example, in the diagram below, how can we filter for rows that contain a diamond shape? We can use dplyr’s handy filter function along with logical and boolean operators!\n\nFor reference, here are the operators we can use to specify our conditions with filter.\n\nYou may have noticed that filter accepts the same operators that base R’s subset function does. This is no accident and filter is one of the more accessible tidyverse functions because of the syntax it shares with its base R equivalent.\nTo get familiar with these operators, let’s see some examples!\n\nfilter Example: Exactly Equal\n\n\n\n\n\n\nExample\n\n\n\nTo make a subset of our data that only contains information on Chinstrap penguins, we would use the == operator for “exactly equal to”\n\n# Get all the rows where the species is \"Chinstrap\" \npenguins_filtered <- dplyr::filter(.data = penguins, species == \"Chinstrap\")\n\nhead(penguins_filtered)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_le…¹ body_…² sex    year\n  <fct>     <fct>           <dbl>         <dbl>        <int>   <int> <fct> <int>\n1 Chinstrap Dream            46.5          17.9          192    3500 fema…  2007\n2 Chinstrap Dream            50            19.5          196    3900 male   2007\n3 Chinstrap Dream            51.3          19.2          193    3650 male   2007\n4 Chinstrap Dream            45.4          18.7          188    3525 fema…  2007\n5 Chinstrap Dream            52.7          19.8          197    3725 male   2007\n6 Chinstrap Dream            45.2          17.8          198    3950 fema…  2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\n\nNote that we need to write the value we’re looking for as a character string bookended by quotation marks.\n\n\n\n\nfilter Example: Either / Or\n\n\n\n\n\n\nExample\n\n\n\nWhat if we wanted to get all the rows where the penguin species is “Chinstrap” or “Gentoo”? In other words, we want all the rows where either condition is true. There are two options to do this. The first option is to use the “or” operator, |, between each of the conditions.\n\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Chinstrap\" | species == \"Gentoo\")\n\nhead(penguins_filtered)\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Gentoo  Biscoe           46.1          13.2            211    4500 fema…  2007\n2 Gentoo  Biscoe           50            16.3            230    5700 male   2007\n3 Gentoo  Biscoe           48.7          14.1            210    4450 fema…  2007\n4 Gentoo  Biscoe           50            15.2            218    5700 male   2007\n5 Gentoo  Biscoe           47.6          14.5            215    5400 male   2007\n6 Gentoo  Biscoe           46.5          13.5            210    4550 fema…  2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\n\nThis method works fine for a few options but begins to get cumbersome when you have many possible conditions that you’d like to retain. In these cases you can use the %in% operator followed by a vector of values that you want to include in your filter.\n\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species %in% c(\"Chinstrap\", \"Gentoo\"))\n\nhead(penguins_filtered)\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Gentoo  Biscoe           46.1          13.2            211    4500 fema…  2007\n2 Gentoo  Biscoe           50            16.3            230    5700 male   2007\n3 Gentoo  Biscoe           48.7          14.1            210    4450 fema…  2007\n4 Gentoo  Biscoe           50            15.2            218    5700 male   2007\n5 Gentoo  Biscoe           47.6          14.5            215    5400 male   2007\n6 Gentoo  Biscoe           46.5          13.5            210    4550 fema…  2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\n\n\n\n\n\nfilter Example: Multiple Conditions\n\n\n\n\n\n\nExample\n\n\n\nWe can also keep rows where both conditions are met by using the & operator to specify multiple conditions that must all be true. To keep only the rows where the species is “Adelie” and the island is “Dream”, we can use the following code:\n\n# Get all the rows where the species is \"Adelie\" and the island is \"Dream\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Adelie\" & island == \"Dream\")\n\nhead(penguins_filtered)\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Adelie  Dream            39.5          16.7            178    3250 fema…  2007\n2 Adelie  Dream            37.2          18.1            178    3900 male   2007\n3 Adelie  Dream            39.5          17.8            188    3300 fema…  2007\n4 Adelie  Dream            40.9          18.9            184    3900 male   2007\n5 Adelie  Dream            36.4          17              195    3325 fema…  2007\n6 Adelie  Dream            39.2          21.1            196    4150 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\n\n\n\n\n\nfilter Example: Greater Than / Less Than\n\n\n\n\n\n\nExample\n\n\n\nWhen subsetting by numeric columns, we can use greater than (>) and less than (<) to capture the range of possible values that meet that criteria. If you want to include a “or equal to” clause, just add an equal sign to the right of the greater/less than sign in the operator (e.g., >= or <=).\nFor instance, we can subset the data for only penguins whose bills are longer than 50 millimeters\n\n# Filter based on bill length\npenguins_filtered <- dplyr::filter(.data = penguins, bill_length_mm > 50)\n\nhead(penguins_filtered)\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Gentoo  Biscoe           50.2          14.3            218    5700 male   2007\n2 Gentoo  Biscoe           59.6          17              230    6050 male   2007\n3 Gentoo  Biscoe           50.5          15.9            222    5550 male   2008\n4 Gentoo  Biscoe           50.5          15.9            225    5400 male   2008\n5 Gentoo  Biscoe           50.1          15              225    5000 male   2008\n6 Gentoo  Biscoe           50.4          15.3            224    5550 male   2008\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\n\nNote that when filtering for numeric columns we do not need the quotation marks.\n\n\n\n\nfilter Example: Exclusion Criteria\n\n\n\n\n\n\nExample\n\n\n\nSometimes it’s faster to subset the rows that do not meet a condition, rather than listing everything that we do want to keep. This is where the != operator (or “not equal to”) becomes useful. More generally, the exclamation mark indicates negation in the operator.\n\n# Get all the rows where the species is NOT \"Chinstrap\"\npenguins_filtered <- dplyr::filter(.data = penguins, species != \"Chinstrap\")\n\nhead(penguins_filtered)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n2 Adelie  Torgersen           39.5          17.4         186    3800 fema…  2007\n3 Adelie  Torgersen           40.3          18           195    3250 fema…  2007\n4 Adelie  Torgersen           NA            NA            NA      NA <NA>   2007\n5 Adelie  Torgersen           36.7          19.3         193    3450 fema…  2007\n6 Adelie  Torgersen           39.3          20.6         190    3650 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\n\n\n\n\n\nChallenge: filter\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing filter, how would you get all of the rows that do not have any NA values in the sex column?"
  },
  {
    "objectID": "wrangle.html#making-and-modifying-columns",
    "href": "wrangle.html#making-and-modifying-columns",
    "title": "Wrangle",
    "section": "Making and Modifying Columns",
    "text": "Making and Modifying Columns\nAside from selecting columns and subsetting rows, we may want to create new columns in our data. For instance, in the diagram below, we have a dataframe that only contains column A, and then we add new columns B and C. We can use dplyr’s mutate function to add a new column, while keeping the existing columns.\n\nThe general syntax to add a new column to your dataframe is as follows:\n\nyour_data_v2 <- dplyr::mutate(.data = your_data, new_column_name = what_it_contains)\n\n\nmutate Example: Making New Columns\n\n\n\n\n\n\nExample\n\n\n\nIf we wanted to add a new column that has the penguin’s body mass in kilograms, we can do some arithmetic on the body_mass_g column and store the result in a new column.\n\n# Create a new column with the penguins' body mass in kilograms\npenguins_mutated <- dplyr::mutate(.data = penguins, body_mass_kg = body_mass_g / 1000)\n\nhead(penguins_mutated)\n\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year body_…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int>   <dbl>\n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007    3.75\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007    3.8 \n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007    3.25\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007   NA   \n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007    3.45\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007    3.65\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​body_mass_kg\n\n\n\n\n\n\nmutate Example: Overwriting Existing Columns\n\n\n\n\n\n\nExample\n\n\n\nAdditionally, mutate can be used to overwrite an existing column. If we give the new column the same name as an existing column, the existing column will be replaced. As you can see, island is currently a factor. To change its class to a character, we would need to overwrite the column.\n\n# Check current format of the `island` column\nclass(penguins$island)\n\n[1] \"factor\"\n\n# Modify the existing island column\npenguins_mutated <- dplyr::mutate(.data = penguins, island = as.character(island))\n\n# the `island` column is now a character!\nclass(penguins_mutated$island)\n\n[1] \"character\"\n\n\nNow island is a character column!\n\n\n\n\nConditional Operations\nSometimes in data wrangling we’ll want to generate a new column where the contents of the column are dependent upon an exisitng column but we have many separate “if X then Y” type statements. Such statements are called “conditional” statements in programming. You may already be familiar with base R’s ifelse function for handling cases where you have an either/or condition.\nIn the tidyverse–specifically dplyr–we have case_when for handling multiple conditions in an efficient and relatively straightforward way! Why are we talking about case_when here? Because you can use case_when inside of a mutate to create a new column based on the conditions that you specify.\nHere is what the general syntax for this operation looks like:\n\nyour_data_v2 <- dplyr::mutate(.data = your_data,\n              new_column_name = dplyr::case_when(\n                condition1 ~ value_for_condition1,\n                condition2 ~ value_for_condition2,\n                condition3 ~ value_for_condition3,\n                  ...\n                TRUE ~ value_if_no_conditions_are_met))\n\nLet’s look at an example to make this somewhat more tangible.\n\n\nmutate + case_when Example: Creating a New Column Conditionally\n\n\n\n\n\n\nExample\n\n\n\nSuppose we want to add a new column called flipper_rank that contains the following:\n\n2 if flipper_length_mm is >= 200 mm\n1 if flipper_length_mm is < 200 mm\n0 is flipper_length_mm is anything else (e.g. NA)\n\n\n# Enter your conditions on the left side and the values on the right side of the tilde\npenguins_mutated <- dplyr::mutate(.data = penguins,\n                                  flipper_rank = dplyr::case_when(\n                      flipper_length_mm < 200 ~ 1,\n                      flipper_length_mm >= 200 ~ 2,\n                      TRUE ~ 0))\n\nhead(penguins_mutated)\n\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year flipp…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int>   <dbl>\n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007       1\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007       1\n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007       1\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007       0\n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007       1\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007       1\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​flipper_rank\n\n\n\n\n\n\nChallenge: mutate + case_when\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing mutate and case_when, create a new column called size_bin that contains the following:\n\n“large” if body mass is greater than 4500 grams\n“medium” if body mass is greater than 3000 grams, and less than or equal to 4500 grams\n“small” if body mass is less than or equal to 3000 grams\n\n\n\n\n\nSplitting a Column into Multiple Columns\nAnother relatively common task in data wrangling involves splitting the contents of one column into several columns. To demonstrate, let’s first make a new column that contains the full scientific names for these penguins using mutate and case_when.\n\n# Remember that conditions are on the left side and the values are on the right side of the tilde\npenguins_v1 <- dplyr::mutate(.data = penguins, scientific_name = dplyr::case_when(\n  species == \"Adelie\" ~ \"Pygoscelis_adeliae\",\n  species == \"Chinstrap\" ~ \"Pygoscelis_antarcticus\",\n  species == \"Gentoo\" ~ \"Pygoscelis_papua\"))\n\nhead(penguins_v1)\n\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year scien…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int> <chr>  \n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007 Pygosc…\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007 Pygosc…\n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007 Pygosc…\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007 Pygosc…\n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007 Pygosc…\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007 Pygosc…\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​scientific_name\n\n\nIf we want to split the scientific name into genus and specific epithet, we can use the separate function from the tidyr package.\n\n\nseparate Example: Splitting a Column Apart\n\n\n\n\n\n\nExample\n\n\n\nUsing our new scientific name column, suppose we want to split it so that scientific_name becomes two columns: genus and epithet. Using tidyr’s separate function we can do this in a single step!\n\n# Indicate the column you want to split, the separator, and the new column names!\npenguins_separated <- tidyr::separate(data = penguins_v1,\n                                      col = scientific_name,\n                                      sep = \"_\",\n                                      into = c(\"genus\", \"epithet\"))\n\nhead(penguins_separated)\n\n# A tibble: 6 × 10\n  species island    bill_len…¹ bill_…² flipp…³ body_…⁴ sex    year genus epithet\n  <fct>   <fct>          <dbl>   <dbl>   <int>   <int> <fct> <int> <chr> <chr>  \n1 Adelie  Torgersen       39.1    18.7     181    3750 male   2007 Pygo… adeliae\n2 Adelie  Torgersen       39.5    17.4     186    3800 fema…  2007 Pygo… adeliae\n3 Adelie  Torgersen       40.3    18       195    3250 fema…  2007 Pygo… adeliae\n4 Adelie  Torgersen       NA      NA        NA      NA <NA>   2007 Pygo… adeliae\n5 Adelie  Torgersen       36.7    19.3     193    3450 fema…  2007 Pygo… adeliae\n6 Adelie  Torgersen       39.3    20.6     190    3650 male   2007 Pygo… adeliae\n# … with abbreviated variable names ¹​bill_length_mm, ²​bill_depth_mm,\n#   ³​flipper_length_mm, ⁴​body_mass_g"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Content Creators",
    "section": "",
    "text": "This workshop was created and facilitated by a dynamic team that is here to assist you before, during, and after your attendance at the workshop! To learn a bit more about us, see our bios and relevant links below."
  },
  {
    "objectID": "about.html#julien-brun",
    "href": "about.html#julien-brun",
    "title": "Content Creators",
    "section": "Julien Brun",
    "text": "Julien Brun\nbrunj7.github.io –  brunj7 –  @brunj7 – brun@nceas.ucsb.edu\n\nAs a senior data scientist, the core of Julien’s work is to understand the data and computing challenges researchers are facing and help them to translate these challenges into solvable tasks. Julien advises and mentors on how to clean, structure, combine, and analyze their heterogeneous data sets, as well as scaling up their analysis while promoting open and reproducible data science principles.\nJulien is also a Lecturer in the Master in Environmental Data Science program at Bren School of Environmental Science and Management at UC Santa Barbara, where he teaches “good enough” practices in reproducible and collaborative data science."
  },
  {
    "objectID": "about.html#angel-chen",
    "href": "about.html#angel-chen",
    "title": "Content Creators",
    "section": "Angel Chen",
    "text": "Angel Chen\n angelchen7 – anchen@nceas.ucsb.edu\n\nAngel supports LTER synthesis working groups by developing data pipelines and reproducible analytical workflows to integrate various sources of data. Angel previously worked as a data curator for the Arctic Data Center, helping researchers archive and store their data. Angel recently completed a B.S. in statistics & data science at the University of California, Santa Barbara."
  },
  {
    "objectID": "about.html#nick-lyon",
    "href": "about.html#nick-lyon",
    "title": "Content Creators",
    "section": "Nick Lyon",
    "text": "Nick Lyon\nnjlyon0.github.io –  njlyon0 –  @scilyon – lyon@nceas.ucsb.edu\n\nAs a trained community ecologist, Nick is no stranger to the realities of “messy” environmental data and has learned the tidyverse as part of an effort to reproducibly manage those data for analysis and visualization. His zeal for the tidyverse is born out of the number of times these tools have allowed him to untangle a rat’s nest of idiodsyncratic data and he hopes this workshop will be valuable to all participants.Nick completed his MS in Ecology and Evolutionary Biology at Iowa State University"
  },
  {
    "objectID": "index.html#programs-to-install",
    "href": "index.html#programs-to-install",
    "title": "Overview",
    "section": "Programs to Install",
    "text": "Programs to Install\n\nR & RStudio\nInstall R and its more convenient (in our opinion) user-interface: RStudio.\nIf you already have R, check that you have at least version 4.0.0 by running the following code:\n\nversion$version.string\n\nIf your version starts with a 3 (e.g., the above code returns “R version 3…”), please update R to make sure all packages behave as expected.\n\n\nR Packages\nInstall the tidyverse and palmerpenguins R packages using the following code:\n\ninstall.packages(\"tidyverse\", \"palmerpenguins\")\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nPlease run the above code even if you already have these packages to update these packages and ensure that your code aligns with the examples and challenges introduced during the workshop."
  },
  {
    "objectID": "index.html#websites-to-visit",
    "href": "index.html#websites-to-visit",
    "title": "Overview",
    "section": "Websites to Visit",
    "text": "Websites to Visit\n\nSupplemental Material\nWhile not technically necessary to attend the workshop, if you’d like you can see the content that created the workshop website you are viewing by visiting our GitHub repository here.\nAlso, check out NCEAS’ Learning Hub for a complete list of workshops and trainings offered by NCEAS."
  },
  {
    "objectID": "index.html#penguin-data",
    "href": "index.html#penguin-data",
    "title": "Overview",
    "section": "Penguin Data",
    "text": "Penguin Data\nThe data we’ll be using for this workshop comes from the palmerpenguins package, maintained by Allison Horst. The “penguins” dataset from this package contains size measurements for adult foraging penguins near Palmer Station, Antarctica. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. Let’s take a look at it!\n\n\n\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n# ℹ Use `print(n = ...)` to see more rows\n\n\nThe “penguins” dataset has 344 rows and 8 columns.\nThe columns are as follows:\nspecies: a factor denoting penguin species (Adélie, Chinstrap and Gentoo)\nisland: a factor denoting island in Palmer Archipelago, Antarctica (Biscoe, Dream or Torgersen)\nbill_length_mm: a number denoting bill length (millimeters)\nbill_depth_mm: a number denoting bill depth (millimeters)\nflipper_length_mm: an integer denoting flipper length (millimeters)\nbody_mass_g: an integer denoting body mass (grams)\nsex: a factor denoting penguin sex (female, male)\nyear: an integer denoting the study year (2007, 2008, or 2009)\nThis dataset is an example of tidy data, which means that each variable is in its own column and each observation is in its own row. Generally speaking, functions from packages in the tidyverse expect tidy data though they can be used in some cases to help get data into tidy format! Regardless, the penguins dataset is what we’ll use for all examples in this workshop so be sure that you install the palmerpenguins R package. The examples on this page were adapted from Allison Horst’s dplyr tutorial!"
  },
  {
    "objectID": "reshape.html#defining-shape",
    "href": "reshape.html#defining-shape",
    "title": "Reshape",
    "section": "Defining “Shape”",
    "text": "Defining “Shape”\nBefore talking about how to reshape your data between wide and long format, let’s talk about what “shape” means in reference to data. Fundamentally, “long” data are data with more rows than columns while “wide” data tend to have more columns than rows.\nFor example, in community ecology a “wide” dataframe could have each row being a site that researchers visited while each column could be a different species where the value in the row is the number of individuals of that species at that site. On the other hand, the penguins dataframe we’ve been working with so far is in “long” format because it has one row per penguin and multiple penguins are stacked up.\nBoth wide and long format data can be useful in certain contexts and it is sometimes most intuitive to reshape data from one form to the other (and sometimes back again to the original form!)."
  },
  {
    "objectID": "reshape.html#reshaping-data",
    "href": "reshape.html#reshaping-data",
    "title": "Reshape",
    "section": "Reshaping Data",
    "text": "Reshaping Data\nThe tidyr package contains the intuitively-named pivot_wider and pivot_longer for doing exactly this reshaping.\nTo help demonstrate these two functions, let’s begin by summarizing our dataframe to make changing the shape of the dataframe more visible than it would be with the full dataframe. For example, let’s calculate the average bill length of each penguin species on each island.\n\n# Begin by naming our new data and the data they come from\npenguins_simp <- penguins %>%\n  # Now group by species and island\n  dplyr::group_by(species, island) %>%\n  # Calculate average bill length\n  dplyr::summarize(avg_bill_length_mm = mean(bill_length_mm, na.rm = TRUE)) %>%\n  # And don't forget to ungroup!\n  dplyr::ungroup()\n\n# And this is what we're left with:\npenguins_simp\n\n# A tibble: 5 × 3\n  species   island    avg_bill_length_mm\n  <fct>     <fct>                  <dbl>\n1 Adelie    Biscoe                  39.0\n2 Adelie    Dream                   38.5\n3 Adelie    Torgersen               39.0\n4 Chinstrap Dream                   48.8\n5 Gentoo    Biscoe                  47.5\n\n\nGreat! We can use this smaller data object to demonstrate reshaping more clearly. Let’s begin with an example for pivot_wider.\n\npivot_wider Example: Reshaping to Wide Format\n\n\n\n\n\n\nExample\n\n\n\npivot_wider takes long format data and reshapes it into wide format.\n\nLet’s say that we want to take that data object and reshape it into wide format so that each island is a column and each species of penguin is a row. The contents of each cell then are going to be the average bill length values that we just calculated.\n\n# Begin by naming the objects\npenguins_wide <- penguins_simp %>%\n  # And now we can pivot wider with `pivot_wider`!\n  tidyr::pivot_wider(\n    names_from = island,\n    values_from = avg_bill_length_mm )\n\n# Take a look!\npenguins_wide\n\n# A tibble: 3 × 4\n  species   Biscoe Dream Torgersen\n  <fct>      <dbl> <dbl>     <dbl>\n1 Adelie      39.0  38.5      39.0\n2 Chinstrap   NA    48.8      NA  \n3 Gentoo      47.5  NA        NA  \n\n\nGreat! We now have each island as a column, each row is a penguin species, and the bill length measurement we took is included in each cell. Note that in this specific case this makes the number somewhat ambiguous so we might want to use dplyr’s select or the more specific rename to change the island names to be clearer that those values are bill lengths in milimeters.\n\n\n\n\npivot_longer Example: Reshaping to Long Format\n\n\n\n\n\n\nExample\n\n\n\nNow that we have a small wide format data object, we can feed it to pivot_longer and reshape our data into long format! pivot_longer has very similar syntax except that with pivot_longer you need to tell the function which columns should be reshaped.\npivot_wider on the other hand knows which columns to move around because you manually specify them in the “names_from” and “values_from” arguments.\n\n\n# Begin with our wide data\npenguins_wide %>%\n  # And reshape back into long format\n  pivot_longer(\n    cols = -species,\n    names_to = \"island_name\",\n    values_to = \"mean_bill_length_mm\" )\n\n# A tibble: 9 × 3\n  species   island_name mean_bill_length_mm\n  <fct>     <chr>                     <dbl>\n1 Adelie    Biscoe                     39.0\n2 Adelie    Dream                      38.5\n3 Adelie    Torgersen                  39.0\n4 Chinstrap Biscoe                     NA  \n5 Chinstrap Dream                      48.8\n6 Chinstrap Torgersen                  NA  \n7 Gentoo    Biscoe                     47.5\n8 Gentoo    Dream                      NA  \n9 Gentoo    Torgersen                  NA  \n\n\nTwo quick things to note here:\n\nFirst, pivot_longer included the cells that were NA in the wide version of the data.\n\nThis default behavior is really nice so that you don’t lose any cells implicitly (though you can always filter them out if you don’t want them!).\n\nSecond, you’ll note that in the “cols” argument I only told pivot_longer to not include the “species” column using the same notation you could use for the select function in the dplyr package.\n\nThis is very handy because it lets us write really concise values in the “cols” argument and the default becomes “everything except what was specified”.\nNote that we could have also said cols = Biscoe, Dream, Torgersen and achieved the same reshaping of the data.\n\n\n\n\n\n\nChallenge: Reshaping\n\n\n\n\n\n\nYour Turn!\n\n\n\nThe code below creates a data object that includes the flipper length of all Adelie penguins; what code would you add to reshape the data so that each sex is a column with flipper lengths in the cells?\n\npenguins %>%\n  # Keep only Adelie penguins of known sex\n  dplyr::filter(species == \"Adelie\" & !is.na(sex)) %>%\n  # Calculate the average flipper length by island and sex\n  dplyr::group_by(island, sex) %>%\n  dplyr::summarize(avg_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE)) %>%\n  # Ungroup (good practice to include this step!)\n  dplyr::ungroup()\n\n# A tibble: 6 × 3\n  island    sex    avg_flipper_length_mm\n  <fct>     <fct>                  <dbl>\n1 Biscoe    female                  187.\n2 Biscoe    male                    190.\n3 Dream     female                  188.\n4 Dream     male                    192.\n5 Torgersen female                  188.\n6 Torgersen male                    195."
  },
  {
    "objectID": "join.html#combining-data",
    "href": "join.html#combining-data",
    "title": "Join",
    "section": "Combining data",
    "text": "Combining data\nNow that we know how to manipulate a single dataframe, how do we manipulate multiple dataframes? If we have multiple sources of data and we want to combine them together into one dataframe or table, we can join them through any shared column(s)! Data you’ll be joining can be called “relational data”, because there is some kind of relationship between the dataframes that you’ll be leveraging. In the tidyverse, combining data that has a relationship is called “joining”. Let’s look at some of dplyr’s many join functions!\nIn each of the following join functions, you provide two dataframes, the one you arbitrarily provide first is called the “left” dataframe while the other is called the “right” dataframe. This is important because each of the different join functions brings the columns from one of the dataframes into the other depending on (1) which dataframe is left and which is right and (2) what type of join you specify.\nThis becomes somewhat more intuitive when looking at tangible examples so let’s prepare some data to join in different ways!\n\njoin Data Preparation\nFor demonstration purposes, let’s add a new column called record_number to our penguins data and call the new dataframe penguins_tidy. As you can see below, each row is now numbered from 1 to the length of the dataframe.\n\n# Add a column called `record_number` to our penguins dataset\npenguins_tidy <- penguins %>%\n    dplyr::mutate(record_number = 1:n())\n\nhead(penguins_tidy)\n\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year recor…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int>   <int>\n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007       1\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007       2\n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007       3\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007       4\n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007       5\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007       6\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​record_number\n\n\nThe palmerpenguins package also has a “penguins_raw” dataset with additional, raw information on the same penguins, such as their sampling region, unique identifier, and the date when their nest was observed. Again, for demonstration purposes, let’s add a new column called record_number and call this new dataframe penguins_raw.\n\n# Add a column called `record_number` to our raw penguins dataset\npenguins_raw <- penguins_raw %>%\n  dplyr::mutate(record_number = 1:n()) %>%\n  dplyr::select(record_number, Region, `Individual ID`, `Date Egg`)\n\nhead(penguins_raw)\n\n# A tibble: 6 × 4\n  record_number Region `Individual ID` `Date Egg`\n          <int> <chr>  <chr>           <date>    \n1             1 Anvers N1A1            2007-11-11\n2             2 Anvers N1A2            2007-11-11\n3             3 Anvers N2A1            2007-11-16\n4             4 Anvers N2A2            2007-11-16\n5             5 Anvers N3A1            2007-11-16\n6             6 Anvers N3A2            2007-11-16\n\n\nNow that we have two dataframes that both have a column called record_number, we can join them together to combine information in various ways!\n\n\nleft_join Example: Prioritize the “Left” Dataframe\n\n\n\n\n\n\nExample\n\n\n\nIn a left_join, we bring the columns from the right dataframe that match rows found in the specified column(s) of the left dataframe.\n\nWe can specify the column that we want to join based on with by = .... If we don’t provide this argument, then dplyr will automatically join on all matching columns between the left and right dataframes. In our case, we want to left_join by record_number.\n\n# Left-join the two dataframes together on the shared column!\npenguins_left_joined <- dplyr::left_join(x = penguins_tidy,\n                                         y = penguins_raw,\n                                         by = \"record_number\")\n\nhead(penguins_left_joined)\n\n# A tibble: 6 × 12\n  species island    bill_le…¹ bill_…² flipp…³ body_…⁴ sex    year recor…⁵ Region\n  <fct>   <fct>         <dbl>   <dbl>   <int>   <int> <fct> <int>   <int> <chr> \n1 Adelie  Torgersen      39.1    18.7     181    3750 male   2007       1 Anvers\n2 Adelie  Torgersen      39.5    17.4     186    3800 fema…  2007       2 Anvers\n3 Adelie  Torgersen      40.3    18       195    3250 fema…  2007       3 Anvers\n4 Adelie  Torgersen      NA      NA        NA      NA <NA>   2007       4 Anvers\n5 Adelie  Torgersen      36.7    19.3     193    3450 fema…  2007       5 Anvers\n6 Adelie  Torgersen      39.3    20.6     190    3650 male   2007       6 Anvers\n# … with 2 more variables: `Individual ID` <chr>, `Date Egg` <date>, and\n#   abbreviated variable names ¹​bill_length_mm, ²​bill_depth_mm,\n#   ³​flipper_length_mm, ⁴​body_mass_g, ⁵​record_number\n# ℹ Use `colnames()` to see all variable names\n\n\nWhat we have in the end is penguins_left_joined, a dataframe with information from both penguins_tidy and penguins_raw! All of the rows in penguins_tidy are kept but only the rows from penguins_raw that have a matching record_number in penguins_tidy are included.\n\n\n\n\nright_join Example: Prioritize the “Right” Dataframe\n\n\n\n\n\n\nExample\n\n\n\nIn a right_join, we bring rows from the left dataframe into the right dataframe based on the values in the specified column(s) of the right dataframe.\n\nAs the names imply, a right_join is the opposite of a left_join.\n\n\n\n\ninner_join Example: Keep Rows Found in Both Dataframes\n\n\n\n\n\n\nExample\n\n\n\nIn an inner_join, we keep only the rows where the values in the column we are joining by are found in both dataframes.\n\nThis can be really useful when one of the dataframes includes supplementary data that has incomplete coverage on the other dataframe and you want to simultaneously combine the dataframes and remove the inevitable NAs that will be created.\nFor example, imagine that you have a dataframe of 100 study sites with information on plant growth and a second dataframe of soil chemistry information. Your grant budget was really tight though so you needed to prioritize sample processing and you only have soil chemistry for 20 of the sites where you have plant growth data.\nIf you use inner_join on your plant growth and soil chemistry datasets, you will create a single dataframe with both chemistry and plant data that only has the sites (i.e., rows) where you had data for both. This dataframe then would likely be ready for analysis because you’d have complete data for every site in the new joined dataframe!\nNote that in an inner_join it doesn’t matter which dataframe is “left” and which is “right” because either way you’re only keeping the rows that are found in both dataframes.\n\n\n\n\nfull_join Example: Combine All Data in Both Dataframes\n\n\n\n\n\n\nExample\n\n\n\nIn a full_join, we keep all values and all rows.\n\nA full_join is “smart” enough to fill with NAs in all rows that don’t match between the two dataframes. Also, just like an inner_join, a full_join doesn’t care about which dataframe is “left” and which is “right” because all columns are getting combined regardless of which is left vs. right.\n\n\n\n\nanti_join Example: Keep Only Columns that Aren’t Shared\n\n\n\n\n\n\nExample\n\n\n\nIn an anti_join, we return rows of the left dataframe that do not have a match in the right dataframe. This can be used to see what will not be included in a join.\n\nOne case where an anti_join is particularly useful is that of “text mining” where you have one dataframe with a column of individual words that you’ve split apart from a larger block of free text. If you also have a dataframe of one column that contains words that you want to remove from your “actual” data (e.g., “and”, “not”, “I”, “me”, etc.), you can anti_join the two dataframes to quickly remove all of those unwanted words from your text mining dataframe.\n\n\n\n\nAdditional Notes\n\nIf we want to join by more than one matching column, we can specify multiple columns with a vector like so: by = c(\"column1\", \"column2\").\nWe can also use a named vector, by = c(\"column_a\" = \"COLUMN_A\") to match on columns that have different names in each dataframe."
  }
]