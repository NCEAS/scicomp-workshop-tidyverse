{
  "hash": "140f3188391b7c663e425ad0b639cc83",
  "result": {
    "markdown": "---\ntitle: \"Wrangle\"\n---\n\n\n\n## What are Tidy Data?\n\nWhat are some common things you like to do with your data? Maybe remove rows or columns, do calculations and add new columns? This is called data wrangling. The data we get to work with are rarely, if ever, in the format we need to do our analyses. `dplyr` and `tidyr` are two R packages from the `tidyverse` that provide a fairly complete and extremely powerful set of functions for us to do virtually all needed wrangling quickly. Here we introduce some commonly used functions from these two packages.\n\nWe can use `glimpse` from the `dplyr` package to look at part of the data while also getting some relevant structural information (i.e., what type of data are in each column, etc.).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"tidyverse\", \"palmerpenguins\")\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\ndplyr::glimpse(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n:::\n:::\n\n\n## Selecting Columns\n\nTo start off, how do we do a fundamental action like selecting the columns we want? `dplyr`'s `select` function provides us with a straightforward way to do just that. We only need to provide the column names!\n\n<img src=\"images/wrangle-select.png\" align=\"center\" width=\"50%\"/>\n\n### `select` Example: Including & Excluding\n\n::: callout-note \n## Example\n\nTo select only the `species`, `island`, and `body_mass_g` columns, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Provide the name of the data and then the columns that you want!\npenguins_selected <- dplyr::select(.data = penguins, species, island, body_mass_g)\n\n# Look at the product\nhead(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  species island    body_mass_g\n  <fct>   <fct>           <int>\n1 Adelie  Torgersen        3750\n2 Adelie  Torgersen        3800\n3 Adelie  Torgersen        3250\n4 Adelie  Torgersen          NA\n5 Adelie  Torgersen        3450\n6 Adelie  Torgersen        3650\n```\n:::\n:::\n\n\nIf we want to remove specific columns, we can use the `-` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Put a \"-\" in front of each column you would like to remove from your dataframe\npenguins_selected <- dplyr::select(.data = penguins, -flipper_length_mm, -sex)\n\n# Look at the product\nhead(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm body_mass_g  year\n  <fct>   <fct>              <dbl>         <dbl>       <int> <int>\n1 Adelie  Torgersen           39.1          18.7        3750  2007\n2 Adelie  Torgersen           39.5          17.4        3800  2007\n3 Adelie  Torgersen           40.3          18          3250  2007\n4 Adelie  Torgersen           NA            NA            NA  2007\n5 Adelie  Torgersen           36.7          19.3        3450  2007\n6 Adelie  Torgersen           39.3          20.6        3650  2007\n```\n:::\n:::\n\n:::\n\n### `select` Example: Selecting with Helper Functions\n\n::: callout-note\n## Example\n\nIf we want to select the columns that contain length measurements, we can manually type `bill_length_mm` and `flipper_length_mm`, but there's actually an easier way using the `contains` function, also from the `dplyr` package. Enter a string that matches what you're looking for among the column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enter a matching string inside of a `select` call\npenguins_selected <- dplyr::select(.data = penguins, dplyr::contains(\"length\"))\n\n# Look at the product\nhead(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  bill_length_mm flipper_length_mm\n           <dbl>             <int>\n1           39.1               181\n2           39.5               186\n3           40.3               195\n4           NA                  NA\n5           36.7               193\n6           39.3               190\n```\n:::\n:::\n\n:::\n\n### `select` Example: Selecting a Range of Columns\n\n:::callout-note\n## Example\n\nNow what if we wanted all the columns from the first column `species` to the sixth column `body_mass_g`? We can use a colon, `:`, between the first (leftmost) and last (rightmost) columns in the range that we want to include.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use a colon to indicate a range of columns you want to select\npenguins_selected <- dplyr::select(.data = penguins, species:body_mass_g)\n\n# Look at the product\nhead(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n```\n:::\n:::\n\n\nConveniently selecting a range of columns can be especially useful when you have a big dataframe and don't want to exhaustively list every column by name.\n:::\n\n## Subsetting Rows\n\nInstead of selecting certain columns, how can we get a subset of rows that meet certain conditions? For example, in the diagram below, how can we filter for rows that contain a diamond shape? We can use `dplyr`'s handy `filter` function along with logical and boolean operators!\n\n<img src=\"images/wrangle-filter.png\" align=\"center\" width=\"25%\"/>\n\nFor reference, here are the operators we can use to specify our conditions with `filter`.\n\n<img src=\"images/wrangle-operators.png\" align=\"center\" width=\"90%\"/>\n\nYou may have noticed that `filter` accepts the same operators that base R's `subset` function does. This is no accident and `filter` is one of the more accessible `tidyverse` functions because of the syntax it shares with its base R equivalent.\n\nTo get familiar with these operators, let's see some examples!\n\n### `filter` Example: Exactly Equal\n\n:::callout-note\n## Example\n\nTo make a subset of our data that only contains information on Chinstrap penguins, we would use the `==` operator for \"exactly equal to\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Chinstrap\" \npenguins_filtered <- dplyr::filter(.data = penguins, species == \"Chinstrap\")\n\nhead(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_le…¹ body_…² sex    year\n  <fct>     <fct>           <dbl>         <dbl>        <int>   <int> <fct> <int>\n1 Chinstrap Dream            46.5          17.9          192    3500 fema…  2007\n2 Chinstrap Dream            50            19.5          196    3900 male   2007\n3 Chinstrap Dream            51.3          19.2          193    3650 male   2007\n4 Chinstrap Dream            45.4          18.7          188    3525 fema…  2007\n5 Chinstrap Dream            52.7          19.8          197    3725 male   2007\n6 Chinstrap Dream            45.2          17.8          198    3950 fema…  2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n\nNote that we need to write the value we're looking for as a character string bookended by quotation marks.\n:::\n\n### `filter` Example: Either / Or\n\n:::callout-note\n## Example\n\nWhat if we wanted to get all the rows where the penguin species is \"Chinstrap\" **or** \"Gentoo\"? In other words, we want all the rows where *either* condition is true. There are two options to do this. The first option is to use the \"or\" operator, `|`, between each of the conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Chinstrap\" | species == \"Gentoo\")\n\nhead(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Gentoo  Biscoe           46.1          13.2            211    4500 fema…  2007\n2 Gentoo  Biscoe           50            16.3            230    5700 male   2007\n3 Gentoo  Biscoe           48.7          14.1            210    4450 fema…  2007\n4 Gentoo  Biscoe           50            15.2            218    5700 male   2007\n5 Gentoo  Biscoe           47.6          14.5            215    5400 male   2007\n6 Gentoo  Biscoe           46.5          13.5            210    4550 fema…  2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n\nThis method works fine for a few options but begins to get cumbersome when you have many possible conditions that you'd like to retain. In these cases you can use the `%in%` operator followed by a vector of values that you want to include in your filter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species %in% c(\"Chinstrap\", \"Gentoo\"))\n\nhead(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Gentoo  Biscoe           46.1          13.2            211    4500 fema…  2007\n2 Gentoo  Biscoe           50            16.3            230    5700 male   2007\n3 Gentoo  Biscoe           48.7          14.1            210    4450 fema…  2007\n4 Gentoo  Biscoe           50            15.2            218    5700 male   2007\n5 Gentoo  Biscoe           47.6          14.5            215    5400 male   2007\n6 Gentoo  Biscoe           46.5          13.5            210    4550 fema…  2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n:::\n\n### `filter` Example: Multiple Conditions\n\n:::callout-note\n## Example\n\nWe can also keep rows where both conditions are met by using the `&` operator to specify multiple conditions that must *all* be true. To keep only the rows where the species is \"Adelie\" **and** the island is \"Dream\", we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Adelie\" and the island is \"Dream\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Adelie\" & island == \"Dream\")\n\nhead(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Adelie  Dream            39.5          16.7            178    3250 fema…  2007\n2 Adelie  Dream            37.2          18.1            178    3900 male   2007\n3 Adelie  Dream            39.5          17.8            188    3300 fema…  2007\n4 Adelie  Dream            40.9          18.9            184    3900 male   2007\n5 Adelie  Dream            36.4          17              195    3325 fema…  2007\n6 Adelie  Dream            39.2          21.1            196    4150 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n:::\n\n### `filter` Example: Greater Than / Less Than\n\n:::callout-note\n## Example\n\nWhen subsetting by numeric columns, we can use greater than (`>`) and less than (`<`) to capture the range of possible values that meet that criteria. If you want to include a \"or equal to\" clause, just add an equal sign to the right of the greater/less than sign in the operator (e.g., `>=` or `<=`). \n\nFor instance, we can subset the data for only penguins whose bills are longer than 50 millimeters\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter based on bill length\npenguins_filtered <- dplyr::filter(.data = penguins, bill_length_mm > 50)\n\nhead(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_leng…¹ body_…² sex    year\n  <fct>   <fct>           <dbl>         <dbl>          <int>   <int> <fct> <int>\n1 Gentoo  Biscoe           50.2          14.3            218    5700 male   2007\n2 Gentoo  Biscoe           59.6          17              230    6050 male   2007\n3 Gentoo  Biscoe           50.5          15.9            222    5550 male   2008\n4 Gentoo  Biscoe           50.5          15.9            225    5400 male   2008\n5 Gentoo  Biscoe           50.1          15              225    5000 male   2008\n6 Gentoo  Biscoe           50.4          15.3            224    5550 male   2008\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n\nNote that when filtering for numeric columns we do not need the quotation marks.\n:::\n\n### `filter` Example: Exclusion Criteria\n\n:::callout-note\n## Example\n\nSometimes it's faster to subset the rows that **do not** meet a condition, rather than listing everything that we do want to keep. This is where the `!=` operator (or \"not equal to\") becomes useful. More generally, the exclamation mark indicates negation in the operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is NOT \"Chinstrap\"\npenguins_filtered <- dplyr::filter(.data = penguins, species != \"Chinstrap\")\n\nhead(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n2 Adelie  Torgersen           39.5          17.4         186    3800 fema…  2007\n3 Adelie  Torgersen           40.3          18           195    3250 fema…  2007\n4 Adelie  Torgersen           NA            NA            NA      NA <NA>   2007\n5 Adelie  Torgersen           36.7          19.3         193    3450 fema…  2007\n6 Adelie  Torgersen           39.3          20.6         190    3650 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n:::\n\n### Challenge: `filter`\n\n:::callout-important\n## Your Turn!\n\nUsing `filter`, how would you get all of the rows that **do not** have any `NA` values in the `sex` column?\n:::\n\n\n## Making and Modifying Columns\n\nAside from selecting columns and subsetting rows, we may want to create new columns in our data. For instance, in the diagram below, we have a dataframe that only contains column A, and then we add new columns B and C. We can use `dplyr`'s `mutate` function to add a new column, while keeping the existing columns.\n\n<img src=\"images/wrangle-mutate.png\" align=\"center\" width=\"50%\"/>\n\nThe general syntax to add a new column to your dataframe is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyour_data_v2 <- dplyr::mutate(.data = your_data, new_column_name = what_it_contains)\n```\n:::\n\n\n### `mutate` Example: Making New Columns\n\n:::callout-note\n## Example\n\nIf we wanted to add a new column that has the penguin's body mass in kilograms, we can do some arithmetic on the `body_mass_g` column and store the result in a new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a new column with the penguins' body mass in kilograms\npenguins_mutated <- dplyr::mutate(.data = penguins, body_mass_kg = body_mass_g / 1000)\n\nhead(penguins_mutated)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year body_…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int>   <dbl>\n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007    3.75\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007    3.8 \n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007    3.25\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007   NA   \n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007    3.45\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007    3.65\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​body_mass_kg\n```\n:::\n:::\n\n:::\n\n### `mutate` Example: Overwriting Existing Columns\n\n:::callout-note\n## Example\n\nAdditionally, `mutate` can be used to overwrite an existing column. If we give the new column the same name as an existing column, the existing column will be **replaced**. As you can see, `island` is currently a factor. To change its class to a character, we would need to overwrite the column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check current format of the `island` column\nclass(penguins$island)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\n# Modify the existing island column\npenguins_mutated <- dplyr::mutate(.data = penguins, island = as.character(island))\n\n# the `island` column is now a character!\nclass(penguins_mutated$island)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nNow `island` is a character column!\n:::\n\n\n### Conditional Operations\n\nSometimes in data wrangling we'll want to generate a new column where the contents of the column are dependent upon an exisitng column but we have many separate \"if X then Y\" type statements. Such statements are called \"conditional\" statements in programming. You may already be familiar with base R's `ifelse` function for handling cases where you have an either/or condition.\n\nIn the `tidyverse`--specifically `dplyr`--we have `case_when` for handling multiple conditions in an efficient and relatively straightforward way! Why are we talking about `case_when` here? Because you can use `case_when` inside of a `mutate` to create a new column based on the conditions that you specify.\n\nHere is what the general syntax for this operation looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyour_data_v2 <- dplyr::mutate(.data = your_data,\n              new_column_name = dplyr::case_when(\n                condition1 ~ value_for_condition1,\n                condition2 ~ value_for_condition2,\n                condition3 ~ value_for_condition3,\n                  ...\n                TRUE ~ value_if_no_conditions_are_met))\n```\n:::\n\n\nLet's look at an example to make this somewhat more tangible.\n\n### `mutate` + `case_when` Example: Creating a New Column Conditionally\n\n:::callout-note\n## Example\n\nSuppose we want to add a new column called `flipper_rank` that contains the following:\n\n-   2 if `flipper_length_mm` is \\>= 200 mm\n-   1 if `flipper_length_mm` is \\< 200 mm\n-   0 is `flipper_length_mm` is anything else (e.g. `NA`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enter your conditions on the left side and the values on the right side of the tilde\npenguins_mutated <- dplyr::mutate(.data = penguins,\n                                  flipper_rank = dplyr::case_when(\n                      flipper_length_mm < 200 ~ 1,\n                      flipper_length_mm >= 200 ~ 2,\n                      TRUE ~ 0))\n\nhead(penguins_mutated)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year flipp…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int>   <dbl>\n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007       1\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007       1\n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007       1\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007       0\n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007       1\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007       1\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​flipper_rank\n```\n:::\n:::\n\n:::\n\n### Challenge: `mutate` + `case_when`\n\n:::callout-important\n## Your Turn!\n\nUsing `mutate` and `case_when`, create a new column called `size_bin` that contains the following:\n\n-   \"large\" if body mass is greater than 4500 grams\n-   \"medium\" if body mass is greater than 3000 grams, and less than or equal to 4500 grams\n-   \"small\" if body mass is less than or equal to 3000 grams\n:::\n\n### Splitting a Column into Multiple Columns\n\nAnother relatively common task in data wrangling involves splitting the contents of one column into several columns. To demonstrate, let's first make a new column that contains the full scientific names for these penguins using `mutate` and `case_when`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remember that conditions are on the left side and the values are on the right side of the tilde\npenguins_v1 <- dplyr::mutate(.data = penguins, scientific_name = dplyr::case_when(\n  species == \"Adelie\" ~ \"Pygoscelis_adeliae\",\n  species == \"Chinstrap\" ~ \"Pygoscelis_antarcticus\",\n  species == \"Gentoo\" ~ \"Pygoscelis_papua\"))\n\nhead(penguins_v1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year scien…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int> <chr>  \n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007 Pygosc…\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007 Pygosc…\n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007 Pygosc…\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007 Pygosc…\n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007 Pygosc…\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007 Pygosc…\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​scientific_name\n```\n:::\n:::\n\n\nIf we want to split the scientific name into genus and specific epithet, we can use the `separate` function from the `tidyr` package.\n\n### `separate` Example: Splitting a Column Apart\n\n:::callout-note\n## Example\n\nUsing our new scientific name column, suppose we want to split it so that `scientific_name` becomes two columns: `genus` and `epithet`. Using `tidyr`'s `separate` function we can do this in a single step!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Indicate the column you want to split, the separator, and the new column names!\npenguins_separated <- tidyr::separate(data = penguins_v1,\n                                      col = scientific_name,\n                                      sep = \"_\",\n                                      into = c(\"genus\", \"epithet\"))\n\nhead(penguins_separated)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  species island    bill_len…¹ bill_…² flipp…³ body_…⁴ sex    year genus epithet\n  <fct>   <fct>          <dbl>   <dbl>   <int>   <int> <fct> <int> <chr> <chr>  \n1 Adelie  Torgersen       39.1    18.7     181    3750 male   2007 Pygo… adeliae\n2 Adelie  Torgersen       39.5    17.4     186    3800 fema…  2007 Pygo… adeliae\n3 Adelie  Torgersen       40.3    18       195    3250 fema…  2007 Pygo… adeliae\n4 Adelie  Torgersen       NA      NA        NA      NA <NA>   2007 Pygo… adeliae\n5 Adelie  Torgersen       36.7    19.3     193    3450 fema…  2007 Pygo… adeliae\n6 Adelie  Torgersen       39.3    20.6     190    3650 male   2007 Pygo… adeliae\n# … with abbreviated variable names ¹​bill_length_mm, ²​bill_depth_mm,\n#   ³​flipper_length_mm, ⁴​body_mass_g\n```\n:::\n:::\n\n:::\n",
    "supporting": [
      "wrangle_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}