{
  "hash": "ffc1522cfb8e3ac86847ddab6938f51f",
  "result": {
    "markdown": "---\ntitle: \"Join\"\n---\n\n::: {.cell}\n\n:::\n\n\n## Combining data\n\nNow that we know how to manipulate a single dataframe, how do we manipulate multiple dataframes? If we have multiple sources of data and we want to combine them together into one dataframe or table, we can **join** them through any shared column(s)! Data you'll be joining can be called \"relational data\", because there is some kind of relationship between the dataframes that you’ll be leveraging. In the `tidyverse`, combining data that has a relationship is called \"joining\". Let's look at some of `dplyr`'s many `join` functions!\n\nIn each of the following `join` functions, you provide two dataframes, the one you arbitrarily provide first is called the \"left\" dataframe while the other is called the \"right\" dataframe. This is important because each of the different `join` functions brings the columns from one of the dataframes into the other depending on (1) which dataframe is left and which is right and (2) what type of `join` you specify.\n\nThis becomes somewhat more intuitive when looking at tangible examples so let's prepare some data to `join` in different ways!\n\n### `join` Data Preparation\n\nFor demonstration purposes, let's add a new column called `record_number` to our penguins data and call the new dataframe `penguins_tidy`. As you can see below, each row is now numbered from 1 to the length of the dataframe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a column called `record_number` to our penguins dataset\npenguins_tidy <- penguins %>%\n    dplyr::mutate(record_number = 1:n())\n\nhead(penguins_tidy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_de…¹ flipp…² body_…³ sex    year recor…⁴\n  <fct>   <fct>              <dbl>     <dbl>   <int>   <int> <fct> <int>   <int>\n1 Adelie  Torgersen           39.1      18.7     181    3750 male   2007       1\n2 Adelie  Torgersen           39.5      17.4     186    3800 fema…  2007       2\n3 Adelie  Torgersen           40.3      18       195    3250 fema…  2007       3\n4 Adelie  Torgersen           NA        NA        NA      NA <NA>   2007       4\n5 Adelie  Torgersen           36.7      19.3     193    3450 fema…  2007       5\n6 Adelie  Torgersen           39.3      20.6     190    3650 male   2007       6\n# … with abbreviated variable names ¹​bill_depth_mm, ²​flipper_length_mm,\n#   ³​body_mass_g, ⁴​record_number\n```\n:::\n:::\n\n\nThe `palmerpenguins` package also has a \"penguins_raw\" dataset with additional, raw information on the same penguins, such as their sampling region, unique identifier, and the date when their nest was observed. Again, for demonstration purposes, let's add a new column called `record_number` and call this new dataframe `penguins_raw`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a column called `record_number` to our raw penguins dataset\npenguins_raw <- penguins_raw %>%\n  dplyr::mutate(record_number = 1:n()) %>%\n  dplyr::select(record_number, Region, `Individual ID`, `Date Egg`)\n\nhead(penguins_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  record_number Region `Individual ID` `Date Egg`\n          <int> <chr>  <chr>           <date>    \n1             1 Anvers N1A1            2007-11-11\n2             2 Anvers N1A2            2007-11-11\n3             3 Anvers N2A1            2007-11-16\n4             4 Anvers N2A2            2007-11-16\n5             5 Anvers N3A1            2007-11-16\n6             6 Anvers N3A2            2007-11-16\n```\n:::\n:::\n\n\nNow that we have two dataframes that both have a column called `record_number`, we can `join` them together to combine information in various ways!\n\n### `left_join` Example: Prioritize the \"Left\" Dataframe\n\n:::callout-note\n## Example\n\nIn a `left_join`, we bring the columns from the right dataframe that match rows found in the specified column(s) of the left dataframe.\n\n<img src=\"images/join-left.png\" align=\"center\" width=\"50%\" />\n\nWe can specify the column that we want to join based on with `by = ...`. If we don't provide this argument, then `dplyr` will automatically join on **all** matching columns between the left and right dataframes. In our case, we want to `left_join` by `record_number`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Left-join the two dataframes together on the shared column!\npenguins_left_joined <- dplyr::left_join(x = penguins_tidy,\n                                         y = penguins_raw,\n                                         by = \"record_number\")\n\nhead(penguins_left_joined)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 12\n  species island    bill_le…¹ bill_…² flipp…³ body_…⁴ sex    year recor…⁵ Region\n  <fct>   <fct>         <dbl>   <dbl>   <int>   <int> <fct> <int>   <int> <chr> \n1 Adelie  Torgersen      39.1    18.7     181    3750 male   2007       1 Anvers\n2 Adelie  Torgersen      39.5    17.4     186    3800 fema…  2007       2 Anvers\n3 Adelie  Torgersen      40.3    18       195    3250 fema…  2007       3 Anvers\n4 Adelie  Torgersen      NA      NA        NA      NA <NA>   2007       4 Anvers\n5 Adelie  Torgersen      36.7    19.3     193    3450 fema…  2007       5 Anvers\n6 Adelie  Torgersen      39.3    20.6     190    3650 male   2007       6 Anvers\n# … with 2 more variables: `Individual ID` <chr>, `Date Egg` <date>, and\n#   abbreviated variable names ¹​bill_length_mm, ²​bill_depth_mm,\n#   ³​flipper_length_mm, ⁴​body_mass_g, ⁵​record_number\n# ℹ Use `colnames()` to see all variable names\n```\n:::\n:::\n\n\nWhat we have in the end is `penguins_left_joined`, a dataframe with information from both `penguins_tidy` and `penguins_raw`! *All* of the rows in `penguins_tidy` are kept but only the rows from `penguins_raw` that have a matching `record_number` in `penguins_tidy` are included.\n:::\n\n### `right_join` Example: Prioritize the \"Right\" Dataframe\n\n:::callout-note\n## Example\n\nIn a `right_join`, we bring rows from the left dataframe into the right dataframe based on the values in the specified column(s) of the right dataframe.\n\n<img src=\"images/join-right.png\" align=\"center\" width=\"50%\" />\n\nAs the names imply, a `right_join` is the opposite of a `left_join`.\n:::\n\n### `inner_join` Example: Keep Rows Found in *Both* Dataframes\n\n:::callout-note\n## Example\n\nIn an `inner_join`, we keep only the rows where the values in the column we are joining `by` are found in both dataframes. \n\n<img src=\"images/join-inner.png\" align=\"center\" width=\"50%\" />\n\nThis can be really useful when one of the dataframes includes supplementary data that has incomplete coverage on the other dataframe and you want to simultaneously combine the dataframes and remove the inevitable `NA`s that will be created.\n\nFor example, imagine that you have a dataframe of 100 study sites with information on plant growth and a second dataframe of soil chemistry information. Your grant budget was really tight though so you needed to prioritize sample processing and you only have soil chemistry for 20 of the sites where you have plant growth data.\n\nIf you use `inner_join` on your plant growth and soil chemistry datasets, you will create a single dataframe with both chemistry and plant data that only has the sites (i.e., rows) where you had data for both. This dataframe then would likely be ready for analysis because you'd have complete data for every site in the new `join`ed dataframe!\n\nNote that in an `inner_join` it doesn't matter which dataframe is \"left\" and which is \"right\" because either way you're only keeping the rows that are found in both dataframes.\n:::\n\n### `full_join` Example: Combine *All* Data in Both Dataframes\n\n:::callout-note\n## Example\n\nIn a `full_join`, we keep all values and all rows. \n\n<img src=\"images/join-full.png\" align=\"center\" width=\"50%\" />\n\nA `full_join` is \"smart\" enough to fill with `NA`s in all rows that don't match between the two dataframes. Also, just like an `inner_join`, a `full_join` doesn't care about which dataframe is \"left\" and which is \"right\" because all columns are getting combined regardless of which is left vs. right.\n:::\n\n### `anti_join` Example: Keep Only Columns that *Aren't* Shared\n\n:::callout-note\n## Example\n\nIn an `anti_join`, we return rows of the left dataframe that do not have a match in the right dataframe. This can be used to see what will **not** be included in a join. \n\n<img src=\"images/join-anti.png\" align=\"center\" width=\"50%\" />\n\nOne case where an `anti_join` is particularly useful is that of \"text mining\" where you have one dataframe with a column of individual words that you've split apart from a larger block of free text. If you also have a dataframe of one column that contains words that you want to remove from your \"actual\" data (e.g., \"and\", \"not\", \"I\", \"me\", etc.), you can `anti_join` the two dataframes to quickly remove all of those unwanted words from your text mining dataframe.\n:::\n\n### Additional Notes\n\n- If we want to join by more than one matching column, we can specify multiple columns with a vector like so: `by = c(\"column1\", \"column2\")`.\n\n- We can also use a named vector, `by = c(\"column_a\" = \"COLUMN_A\")` to match on columns that have different names in each dataframe. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}