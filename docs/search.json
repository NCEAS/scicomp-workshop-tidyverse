[
  {
    "objectID": "join.html#workshop-topic-heading",
    "href": "join.html#workshop-topic-heading",
    "title": "Join",
    "section": "Workshop Topic Heading",
    "text": "Workshop Topic Heading\n\nDuplicate this file (or create new .qmd files) for each major section of the workshop. **Remember to add it to the “_quarto.yml” and run quarto render in the Terminal to add the page to the deployed website!**\ndplyr::…_join() functions\n\nWorkshop Subheading\nIt is worthwhile to use two “#” for headings and three “#” for subheadings to that the live table of the contents on the right hand side of the deployed website allows easy navigation among sections."
  },
  {
    "objectID": "index.html#programs-to-install",
    "href": "index.html#programs-to-install",
    "title": "Overview",
    "section": "Programs to Install",
    "text": "Programs to Install\n\nR & RStudio\nInstall R and its more convenient (in our opinion) user-interface: RStudio.\nIf you already have R, check that you have at least version 4.0.0 by running the following code:\n\nversion$version.string\n\nIf your version starts with a 3 (e.g., the above code returns “R version 3…”), please update R to make sure all packages behave as expected.\n\n\nR Packages\nInstall the tidyverse and palmerpenguins R packages using the following code:\n\ninstall.packages(\"tidyverse\", \"palmerpenguins\")\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nPlease run the above code even if you already have these packages to update these packages and ensure that your code aligns with the examples and challenges introduced during the workshop."
  },
  {
    "objectID": "index.html#websites-to-visit",
    "href": "index.html#websites-to-visit",
    "title": "Overview",
    "section": "Websites to Visit",
    "text": "Websites to Visit\n\nSupplemental Material\nWhile not technically necessary to attend the workshop, if you’d like you can see the content that created the workshop website you are viewing by visiting our GitHub repository here."
  },
  {
    "objectID": "wrangle.html#what-are-tidy-data",
    "href": "wrangle.html#what-are-tidy-data",
    "title": "Wrangle",
    "section": "What are Tidy Data?",
    "text": "What are Tidy Data?\n\nWhat are some common things you like to do with your data? Maybe remove rows or columns, do calculations and add new columns? This is called data wrangling. The data we get to work with are rarely, if ever, in the format we need to do our analyses. dplyr and tidyr are two R packages from the tidyverse that provide a fairly complete and extremely powerful set of functions for us to do virtually all needed wrangling quickly. Here we introduce some commonly used functions from these two packages."
  },
  {
    "objectID": "wrangle.html#penguins-example-data",
    "href": "wrangle.html#penguins-example-data",
    "title": "Wrangle",
    "section": "Penguins Example Data",
    "text": "Penguins Example Data\nThe data we’ll be using for this workshop comes from the palmerpenguins package, maintained by Allison Horst. The “penguins” dataset from this package contains size measurements for adult foraging penguins near Palmer Station, Antarctica. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. Let’s take a look at it!\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n# ℹ Use `print(n = ...)` to see more rows\n\n\nThe “penguins” dataset has 344 rows and 8 columns.\nThe columns are as follows:\nspecies: a factor denoting penguin species (Adélie, Chinstrap and Gentoo)\nisland: a factor denoting island in Palmer Archipelago, Antarctica (Biscoe, Dream or Torgersen)\nbill_length_mm: a number denoting bill length (millimeters)\nbill_depth_mm: a number denoting bill depth (millimeters)\nflipper_length_mm: an integer denoting flipper length (millimeters)\nbody_mass_g: an integer denoting body mass (grams)\nsex: a factor denoting penguin sex (female, male)\nyear: an integer denoting the study year (2007, 2008, or 2009)\nThis dataset is an example of tidy data, which means that each variable is in its own column and each observation is in its own row. Generally speaking, functions from packages in the tidyverse expect tidy data though they can be used in some cases to help get data into tidy format! Regardless, the penguins dataset is what we’ll use for all examples in this workshop so be sure that you install the palmerpenguins R package."
  },
  {
    "objectID": "wrangle.html#selecting-columns",
    "href": "wrangle.html#selecting-columns",
    "title": "Wrangle",
    "section": "Selecting columns",
    "text": "Selecting columns\nTo start off, how do we do a fundamental action like selecting the columns we want? dplyr’s select function provides us with a straightforward way to do just that. We only need to provide the column names!\n\n\nExample: Select\nFor example, to select only the species, island, and body_mass_g columns, we can use the following code:\n\n# Provide the name of the data and then the columns that you want!\npenguins_selected <- dplyr::select(.data = penguins, species, island, body_mass_g)\n\n# Look at the product\nknitr::kable(head(penguins_selected))\n\n\n\n\nspecies\nisland\nbody_mass_g\n\n\n\n\nAdelie\nTorgersen\n3750\n\n\nAdelie\nTorgersen\n3800\n\n\nAdelie\nTorgersen\n3250\n\n\nAdelie\nTorgersen\nNA\n\n\nAdelie\nTorgersen\n3450\n\n\nAdelie\nTorgersen\n3650\n\n\n\n\n\nIf we want to remove specific columns, we can use the - operator.\n\n# Put a \"-\" in front of each column you would like to remove from your dataframe\npenguins_selected <- dplyr::select(.data = penguins, -flipper_length_mm, -sex)\n\n# Look at the product\nknitr::kable(head(penguins_selected))\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nbody_mass_g\nyear\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n3750\n2007\n\n\nAdelie\nTorgersen\n39.5\n17.4\n3800\n2007\n\n\nAdelie\nTorgersen\n40.3\n18.0\n3250\n2007\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\n2007\n\n\nAdelie\nTorgersen\n36.7\n19.3\n3450\n2007\n\n\nAdelie\nTorgersen\n39.3\n20.6\n3650\n2007\n\n\n\n\n\n\n\nExample: Selecting columns with helper functions\nIf we want to select the columns that contain length measurements, we can manually type bill_length_mm and flipper_length_mm, but there’s actually an easier way using the contains function, also from the dplyr package. Enter a string that matches what you’re looking for among the column names.\n\n# Enter a matching string inside of a `select` call\npenguins_selected <- dplyr::select(.data = penguins, dplyr::contains(\"length\"))\n\n# Look at the product\nknitr::kable(head(penguins_selected))\n\n\n\n\nbill_length_mm\nflipper_length_mm\n\n\n\n\n39.1\n181\n\n\n39.5\n186\n\n\n40.3\n195\n\n\nNA\nNA\n\n\n36.7\n193\n\n\n39.3\n190\n\n\n\n\n\nIn addition to contains, starts_with and ends_with are also two other helper functions–also from the dplyr package–that allow you to select columns that starts with or ends with a certain string! For example, if we wanted all the columns that end in “mm”…\n\n# Enter a string that matches the end of the column names\npenguins_selected <- dplyr::select(.data = penguins, dplyr::ends_with(\"_mm\"))\n\n# Look at the product\nknitr::kable(head(penguins_selected))\n\n\n\n\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\n\n\n\n\n39.1\n18.7\n181\n\n\n39.5\n17.4\n186\n\n\n40.3\n18.0\n195\n\n\nNA\nNA\nNA\n\n\n36.7\n19.3\n193\n\n\n39.3\n20.6\n190\n\n\n\n\n\nNow what if we wanted all the columns from the first column species to the sixth column body_mass_g? We can use a colon, :, between the first (leftmost) and last (rightmost) columns in the range that we want to include.\n\n# Use a colon to indicate a range of columns you want to select\npenguins_selected <- dplyr::select(.data = penguins, species:body_mass_g)\n\n# Look at the product\nknitr::kable(head(penguins_selected))\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\n\n\n\n\n\nThese helper functions make it convenient to select multiple columns at once, which is especially useful if you have a big dataframe and don’t want to exhaustively list every column name."
  },
  {
    "objectID": "wrangle.html#subsetting-rows",
    "href": "wrangle.html#subsetting-rows",
    "title": "Wrangle",
    "section": "Subsetting rows",
    "text": "Subsetting rows\nInstead of selecting certain columns, how can we get a subset of rows that meet certain conditions? For example, in the diagram below, how can we filter for rows that contain a diamond shape? We can use dplyr’s handy filter function along with logical and boolean operators!\n\nFor reference, here are the operators we can use to specify our conditions with filter.\n\n\nExample: Equality operator\nTo get familiar with these operators, let’s see some examples. To make a subset of our data that only contains information on Chinstrap penguins, here is what we would do:\n\n# Get all the rows where the species is \"Chinstrap\" \npenguins_filtered <- dplyr::filter(.data = penguins, species == \"Chinstrap\")\n\nknitr::kable(head(penguins_filtered))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nChinstrap\nDream\n46.5\n17.9\n192\n3500\nfemale\n2007\n\n\nChinstrap\nDream\n50.0\n19.5\n196\n3900\nmale\n2007\n\n\nChinstrap\nDream\n51.3\n19.2\n193\n3650\nmale\n2007\n\n\nChinstrap\nDream\n45.4\n18.7\n188\n3525\nfemale\n2007\n\n\nChinstrap\nDream\n52.7\n19.8\n197\n3725\nmale\n2007\n\n\nChinstrap\nDream\n45.2\n17.8\n198\n3950\nfemale\n2007\n\n\n\n\n\nNote that we need to write our match as a string, encased in quotation marks.\n\n\nExample: “Or” statement\nWhat if we wanted to get all the rows where the penguin species is “Chinstrap” or “Gentoo”? In other words, we want all the rows where either condition is true. There are two options to do this. The first option is to use the “or” operator, |, between the conditions.\n\n# First option\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Chinstrap\" | species == \"Gentoo\")\n\nknitr::kable(head(penguins_filtered))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nGentoo\nBiscoe\n46.1\n13.2\n211\n4500\nfemale\n2007\n\n\nGentoo\nBiscoe\n50.0\n16.3\n230\n5700\nmale\n2007\n\n\nGentoo\nBiscoe\n48.7\n14.1\n210\n4450\nfemale\n2007\n\n\nGentoo\nBiscoe\n50.0\n15.2\n218\n5700\nmale\n2007\n\n\nGentoo\nBiscoe\n47.6\n14.5\n215\n5400\nmale\n2007\n\n\nGentoo\nBiscoe\n46.5\n13.5\n210\n4550\nfemale\n2007\n\n\n\n\n\nThe second option is to use the %in% operator, followed by a vector of values to look for a match in. If you want to look for multiple matches, this option may be better since you only need to add to your vector of matches.\n\n# Second option\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species %in% c(\"Chinstrap\", \"Gentoo\"))\n\nknitr::kable(head(penguins_filtered))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nGentoo\nBiscoe\n46.1\n13.2\n211\n4500\nfemale\n2007\n\n\nGentoo\nBiscoe\n50.0\n16.3\n230\n5700\nmale\n2007\n\n\nGentoo\nBiscoe\n48.7\n14.1\n210\n4450\nfemale\n2007\n\n\nGentoo\nBiscoe\n50.0\n15.2\n218\n5700\nmale\n2007\n\n\nGentoo\nBiscoe\n47.6\n14.5\n215\n5400\nmale\n2007\n\n\nGentoo\nBiscoe\n46.5\n13.5\n210\n4550\nfemale\n2007\n\n\n\n\n\n\n\nExample: “And” statement\nWe can also keep rows where both conditions are met by using the “and” operator, &. To keep only the rows where the species is “Adelie” and the island is “Dream”, here is one option we can do:\n\n# First option\n# Get all the rows where the species is \"Adelie\" and the island is \"Dream\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Adelie\" & island == \"Dream\")\n\nknitr::kable(head(penguins_filtered))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nAdelie\nDream\n39.5\n16.7\n178\n3250\nfemale\n2007\n\n\nAdelie\nDream\n37.2\n18.1\n178\n3900\nmale\n2007\n\n\nAdelie\nDream\n39.5\n17.8\n188\n3300\nfemale\n2007\n\n\nAdelie\nDream\n40.9\n18.9\n184\n3900\nmale\n2007\n\n\nAdelie\nDream\n36.4\n17.0\n195\n3325\nfemale\n2007\n\n\nAdelie\nDream\n39.2\n21.1\n196\n4150\nmale\n2007\n\n\n\n\n\nOr you can also just use a comma instead!\n\n# Second option\n# Get all the rows where the species is \"Adelie\" and the island is \"Dream\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Adelie\", island == \"Dream\")\n\nknitr::kable(head(penguins_filtered))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nAdelie\nDream\n39.5\n16.7\n178\n3250\nfemale\n2007\n\n\nAdelie\nDream\n37.2\n18.1\n178\n3900\nmale\n2007\n\n\nAdelie\nDream\n39.5\n17.8\n188\n3300\nfemale\n2007\n\n\nAdelie\nDream\n40.9\n18.9\n184\n3900\nmale\n2007\n\n\nAdelie\nDream\n36.4\n17.0\n195\n3325\nfemale\n2007\n\n\nAdelie\nDream\n39.2\n21.1\n196\n4150\nmale\n2007\n\n\n\n\n\n\n\nExample: Other logical operators\nThe other standard logical operators (<, >, <=, >=) also work pretty intuitively with our conditions. Note that when we filter for numeric values, we do not need the quotation marks.\n\n# Get all the rows where the bill_length_mm is greater than 50\npenguins_filtered <- dplyr::filter(.data = penguins, bill_length_mm > 50)\n\nknitr::kable(head(penguins_filtered))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nGentoo\nBiscoe\n50.2\n14.3\n218\n5700\nmale\n2007\n\n\nGentoo\nBiscoe\n59.6\n17.0\n230\n6050\nmale\n2007\n\n\nGentoo\nBiscoe\n50.5\n15.9\n222\n5550\nmale\n2008\n\n\nGentoo\nBiscoe\n50.5\n15.9\n225\n5400\nmale\n2008\n\n\nGentoo\nBiscoe\n50.1\n15.0\n225\n5000\nmale\n2008\n\n\nGentoo\nBiscoe\n50.4\n15.3\n224\n5550\nmale\n2008\n\n\n\n\n\n\n\nExample: Excluding rows\nSometimes it’s faster to subset the rows that do not meet a condition, rather than listing everything that we do want to keep. This is where the != operator becomes useful. It basically means “does not match”. More generally, the exclamation mark indicates negation in the operator.\n\n# Get all the rows where the species is NOT \"Chinstrap\"\npenguins_filtered <- dplyr::filter(.data = penguins, species != \"Chinstrap\")\n\nknitr::kable(head(penguins_filtered))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n\n\n\n\n\n\n\nChallenge: Subsetting\nAs a practice exercise, try to get all the rows that do not have any NA values in the sex column."
  },
  {
    "objectID": "wrangle.html#making-and-modifying-columns",
    "href": "wrangle.html#making-and-modifying-columns",
    "title": "Wrangle",
    "section": "Making and modifying columns",
    "text": "Making and modifying columns\nBesides selecting columns and subsetting rows, we may want to create new columns in our data. For instance, in the diagram below, we have a dataframe that only contains column A, and then we add new columns B and C. We can use dplyr’s mutate function to add a new column, while keeping the existing columns.\n\n\nExample: Mutate\nThe syntax to add a new column to your dataframe is as follows:\n\n# General mutate syntax\ndplyr::mutate(.data = your_data, new_column_name = what_it_contains)\n\nIf we wanted to add a new column that has the penguin’s body mass in kilograms, we can do some simple arithmetic on the body_mass_g column.\n\n# Create a new column with the penguins' body mass in kilograms\npenguins_mutated <- dplyr::mutate(.data = penguins, body_mass_kg = body_mass_g / 1000)\n\nknitr::kable(head(penguins_mutated))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\nbody_mass_kg\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n3.75\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n3.80\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n3.25\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\nNA\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n3.45\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n3.65\n\n\n\n\n\nAdditionally, mutate can be used to overwrite an existing column. If we give the new column the same name as an existing column, the existing column will be replaced. As you can see, island is currently a factor. To change its class to a character, we would need to overwrite the whole column.\n\n# the `island` column is currently a factor\nclass(penguins$island)\n\n[1] \"factor\"\n\n\n\n# Modify the existing island column\npenguins_mutated <- dplyr::mutate(.data = penguins, island = as.character(island))\n\n# the `island` column is now a character!\nclass(penguins_mutated$island)\n\n[1] \"character\"\n\n\nNow island is a character column!\n\n\nExample: Case When\ndplyr’s case_when is a really powerful tool that allows you to add a new column containing values dependent on your condition(s)! It can be thought of as a multi-case if-else statement. The general syntax for leveraging case_when with mutate looks like this:\n\n# General mutate with case_when syntax\ndplyr::mutate(.data = your_data, new_column_name = dplyr::case_when(\n  condition1 ~ value_for_condition1,\n  condition2 ~ value_for_condition2,\n  condition3 ~ value_for_condition3,\n  ...\n))\n\nSuppose we want to add a new column called flipper_rank that contains:\n\n1 if flipper_length_mm is < 200 mm\n2 if flipper_length_mm is >= 200 mm\n0 is flipper_length_mm is anything else (e.g. NA)\n\n\n# Enter your conditions on the left side and the values on the right side of the tilde\npenguins_mutated <- dplyr::mutate(.data = penguins, flipper_rank = dplyr::case_when(\n  flipper_length_mm < 200 ~ 1,\n  flipper_length_mm >= 200 ~ 2,\n  TRUE ~ 0 # 0 for anything else\n  ))\n\nknitr::kable(head(penguins_mutated))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\nflipper_rank\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n1\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n1\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n1\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\n0\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n1\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n1\n\n\n\n\n\n\n\nChallenge: Case When\nTry to see if you can add a new column called size_bin that contains:\n\n“large” if body mass is greater than 4500 grams\n“medium” if body mass is greater than 3000 grams, and less than or equal to 4500 grams\n“small” if body mass is less than or equal to 3000 grams"
  },
  {
    "objectID": "wrangle.html#splitting-and-uniting-cells",
    "href": "wrangle.html#splitting-and-uniting-cells",
    "title": "Wrangle",
    "section": "Splitting and uniting cells",
    "text": "Splitting and uniting cells\nAnother common task in data wrangling involves splitting or combining cells into individual values. To demonstrate, let’s first make a new column that contains the full scientific names for these penguins using case_when.\n\n# Enter your conditions on the left side and the values on the right side of the tilde\npenguins_v1 <- dplyr::mutate(.data = penguins, scientific_name = dplyr::case_when(\n  species == \"Adelie\" ~ \"Pygoscelis adeliae\",\n  species == \"Chinstrap\" ~ \"Pygoscelis antarcticus\",\n  species == \"Gentoo\" ~ \"Pygoscelis papua\"\n  ))\n\nknitr::kable(head(penguins_v1))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\nscientific_name\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\nPygoscelis adeliae\n\n\n\n\n\n\nExample: Separate\nNow that we have our new column, suppose we want to split it so that scientific_name becomes two columns instead: genus and epithet. We will need to utilize tidyr’s separate function by providing the type of separator and the new column names!\n\n# Indicate the column you want to split, the separator, and the new column names!\npenguins_separated <- tidyr::separate(data = penguins_v1,\n                               col = scientific_name,\n                               sep = \" \",\n                               into = c(\"genus\", \"epithet\"))\n\nknitr::kable(head(penguins_separated))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\ngenus\nepithet\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\nPygoscelis\nadeliae\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\nPygoscelis\nadeliae\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\nPygoscelis\nadeliae\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\nPygoscelis\nadeliae\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\nPygoscelis\nadeliae\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\nPygoscelis\nadeliae\n\n\n\n\n\n\n\nExample: Unite\nTo do the opposite and unite the genus and epithet columns back together into scientific_name, we can use tidyr’s unite function! Just provide the current columns that you want to collapse, the new column name, and the type of separator!\n\n# Indicate the columns you want to unite, the new column name, and the separator!\npenguins_united <- tidyr::unite(data = penguins_separated,\n                             genus, epithet,\n                             col = \"scientific_name\",\n                             sep = \" \")\n\nknitr::kable(head(penguins_united))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\nscientific_name\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\nPygoscelis adeliae\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\nPygoscelis adeliae"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Content Creators",
    "section": "",
    "text": "This workshop was created and facilitated by a dynamic team that is here to assist you before, during, and after your attendance at the workshop! To learn a bit more about us, see our bios and relevant links below."
  },
  {
    "objectID": "about.html#julien-brun",
    "href": "about.html#julien-brun",
    "title": "Content Creators",
    "section": "Julien Brun",
    "text": "Julien Brun\nbrunj7.github.io –  brunj7 –  @brunj7 – brun@nceas.ucsb.edu\n\nAs a senior data scientist, the core of Julien’s work is to understand the data and computing challenges researchers are facing and help them to translate these challenges into solvable tasks. Julien advises and mentors on how to clean, structure, combine, and analyze their heterogeneous data sets, as well as scaling up their analysis while promoting open and reproducible data science principles.\nJulien is also a Lecturer in the Master in Environmental Data Science program at Bren School of Environmental Science and Management at UC Santa Barbara, where he teaches “good enough” practices in reproducible and collaborative data science."
  },
  {
    "objectID": "about.html#angel-chen",
    "href": "about.html#angel-chen",
    "title": "Content Creators",
    "section": "Angel Chen",
    "text": "Angel Chen\n angelchen7 – anchen@nceas.ucsb.edu\n\nAngel supports LTER synthesis working groups by developing data pipelines and reproducible analytical workflows to integrate various sources of data. Angel previously worked as a data curator for the Arctic Data Center, helping researchers archive and store their data. Angel recently completed a B.S. in statistics & data science at the University of California, Santa Barbara."
  },
  {
    "objectID": "about.html#nick-lyon",
    "href": "about.html#nick-lyon",
    "title": "Content Creators",
    "section": "Nick Lyon",
    "text": "Nick Lyon\nnjlyon0.github.io –  njlyon0 –  @scilyon – lyon@nceas.ucsb.edu\n\nAs a trained community ecologist, Nick is no stranger to the realities of “messy” environmental data and has learned the tidyverse as part of an effort to reproducibly manage those data for analysis and visualization. His zeal for the tidyverse is born out of the number of times these tools have allowed him to untangle a rat’s nest of idiodsyncratic data and he hopes this workshop will be valuable to all participants.Nick completed his MS in Ecology and Evolutionary Biology at Iowa State University"
  },
  {
    "objectID": "summarize.html#pipe-operator",
    "href": "summarize.html#pipe-operator",
    "title": "Summarize",
    "section": "Pipe Operator (%>%)",
    "text": "Pipe Operator (%>%)\n\nBefore diving into the tidyverse functions that allow for summarization and group-wise operations, let’s talk about the pipe operator (%>%). The pipe is from the magrittr package and allows chaining together multiple functions without needing to create separate objects at each step as you would have to without the pipe.\n\nExample: Pipe\nAs in the other chapters, let’s use the “penguins” data object found in the palmerpenguins package. Let’s say we want to keep only specimens that have a measurement for both bill length and bill depth and then remove the flipper and body mass columns.\nWithout the pipe–but still using other tidyverse functions–we could go about this like this:\n\n# Filter out the NAs\npenguins_v2 <- dplyr::filter(.data = penguins,\n                              !is.na(bill_length_mm) & !is.na(bill_depth_mm))\n\n# Now strip away the columns we don't want\npenguins_v3 <- dplyr::select(.data = penguins_v2, \n                             -flipper_length_mm, -body_mass_g)\n\n# And we can look at our final product with `base::head`\nhead(penguins_v3)\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm sex     year\n  <fct>   <fct>              <dbl>         <dbl> <fct>  <int>\n1 Adelie  Torgersen           39.1          18.7 male    2007\n2 Adelie  Torgersen           39.5          17.4 female  2007\n3 Adelie  Torgersen           40.3          18   female  2007\n4 Adelie  Torgersen           36.7          19.3 female  2007\n5 Adelie  Torgersen           39.3          20.6 male    2007\n6 Adelie  Torgersen           38.9          17.8 female  2007\n\n\nUsing the pipe though we can simplify this code dramatically! Note that each of the following lines must end with the %>% so that R knows there are more lines to consider.\n\n# We begin with the name of the data object\npenguins %>%\n  # Then we can filter the data\n  dplyr::filter(!is.na(bill_length_mm) & !is.na(bill_depth_mm)) %>%\n  # And strip away the columns we don't want\n  dplyr::select(-flipper_length_mm, -body_mass_g) %>%\n  # And we can even include the `head` argument to see our progress\n  head()\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm sex     year\n  <fct>   <fct>              <dbl>         <dbl> <fct>  <int>\n1 Adelie  Torgersen           39.1          18.7 male    2007\n2 Adelie  Torgersen           39.5          17.4 female  2007\n3 Adelie  Torgersen           40.3          18   female  2007\n4 Adelie  Torgersen           36.7          19.3 female  2007\n5 Adelie  Torgersen           39.3          20.6 male    2007\n6 Adelie  Torgersen           38.9          17.8 female  2007\n\n\nNote that using the pipe allows each line to inherit the data provided by the previous line.\n\n\nChallenge: Pipe\nUsing pipes, filter the data to only include male penguins, keep only the columns for species, island, and body mass, and drop any rows with NA for body mass.\n\n\nAside: Fun History of Why %>% is a “Pipe”\nThe Belgian painter René Magritte famously created a painting titled “The Treachery of Images” featuring a depiction of a smoking pipe above the words “Cest ci n’est pas une pipe” (French for “This is not a pipe”). Magritte’s point was about how the depiction of a thing is not equal to thing itself. The magrittr package takes its name from the painter because it also includes a pipe that functions slightly differently from a command line pipe and uses different characters. Just like Magritte’s pipe, %>% both is and isn’t a pipe!"
  },
  {
    "objectID": "summarize.html#group-wise-summarizing",
    "href": "summarize.html#group-wise-summarizing",
    "title": "Summarize",
    "section": "Group-Wise Summarizing",
    "text": "Group-Wise Summarizing\nNow that we’ve covered the %>% operator we can use it to do group-wise summarization! Technically this summarization does not require the pipe but it does inherently have two steps and thus benefits from using the pipe to chain together those technically separate instructions.\nTo summarize by groups we first define our groups using dplyr’s group_by function and then summarize using summarize (also from dplyr). summarize does require you to specify what calculations you want to perform within your groups though it uses similar syntax to dplyr’s mutate function.\n\nDespite the similarity in syntax between summarize and mutate there are a few crucial differences:\n\nsummarize returns only a single row per group while mutate returns as many rows as are in the original dataframe\nsummarize will automatically remove any columns that aren’t either (1) included in group_by or (2) created by summarize. mutate cannot remove columns so it only creates whatever you tell it to.\n\n\nExample: Summarize\nLet’s say we want to find some summary values for body mass of each species of penguin on each island. To accomplish this we can do the following:\n\n# Begin with the data and a pipe\npenguins %>%\n  # Group by the desired column names\n  dplyr::group_by(species, island) %>%\n  # And summarize in the way we desire\n  dplyr::summarise(\n    # Get average body mass\n    mean_mass_g = mean(body_mass_g, na.rm = TRUE),\n    # Get the standard deviation\n    sd_mass = sd(body_mass_g, na.rm = TRUE),\n    # Count the number of individual penguins of each species at each island\n    n_mass = dplyr::n(),\n    # Calculate standard error from SD and count\n    se_mass = sd_mass / n_mass )\n\n# A tibble: 5 × 6\n# Groups:   species [3]\n  species   island    mean_mass_g sd_mass n_mass se_mass\n  <fct>     <fct>           <dbl>   <dbl>  <int>   <dbl>\n1 Adelie    Biscoe          3710.    488.     44   11.1 \n2 Adelie    Dream           3688.    455.     56    8.13\n3 Adelie    Torgersen       3706.    445.     52    8.56\n4 Chinstrap Dream           3733.    384.     68    5.65\n5 Gentoo    Biscoe          5076.    504.    124    4.07\n\n\nYou can see we also invoked the n function from dplyr to return the size of each group. This function reads any groups created by group_by and returns the count of rows in the dataframe for each group level.\n\n\nChallenge: Summarizing\nUsing what we’ve covered so far, find the number of penguins sampled in each year (regardless of any other grouping variable)."
  },
  {
    "objectID": "summarize.html#grouping-cautionary-note",
    "href": "summarize.html#grouping-cautionary-note",
    "title": "Summarize",
    "section": "Grouping Cautionary Note",
    "text": "Grouping Cautionary Note\ngroup_by can be extremely useful in summarizing a dataframe or creating a new column without losing rows but you need to be careful. Objects created with group_by “remember” their groups until you change the groups or use the function ungroup from dplyr.\nLook at how the output of a grouped data object tells you the number of groups in the output (see beneath this code chunk).\n\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n())\n\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nThis means that all future uses of that pipe will continue to use the grouping established to create the “penguins_count” column. We can stop this by doing the same pipe, but adding ungroup after we’re done using the grouping established by group_by.\n\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n()) %>%\n  dplyr::ungroup()\n\n# A tibble: 5 × 3\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nSee? We calculated with our desired groups but then dropped the grouping structure once we were finished with them. Note also that if you use group_by and do some calculation then re-group by something else by using group_by again, the second use of group_by will not be affected by the first. This means that you only need one ungroup per pipe."
  },
  {
    "objectID": "reshape.html#defining-shape",
    "href": "reshape.html#defining-shape",
    "title": "Reshape",
    "section": "Defining “Shape”",
    "text": "Defining “Shape”\n\nBefore talking about how to reshape your data between wide and long format, let’s talk about what “shape” means in reference to data. Fundamentally, “long” data are data with more rows than columns while “wide” data tend to have more columns than rows.\nFor example, in community ecology a “wide” dataframe could have each row being a site that researchers visited while each column could be a different species where the value in the row is the number of individuals of that species at that site. On the other hand, the penguins dataframe we’ve been working with so far is in “long” format because it has one row per penguin and multiple penguins are stacked up.\nBoth wide and long format data can be useful in certain contexts and it is sometimes most intuitive to reshape data from one form to the other (and sometimes back again to the original form!).\nThe tidyr package contains the intuitively-named pivot_wider and pivot_longer for doing exactly this reshaping.\nTo help demonstrate these two functions, let’s begin by summarizing our dataframe to make changing the shape of the dataframe more visible than it would be with the full dataframe. For example, let’s calculate the average bill length of each penguin species on each island.\n\n# Begin by naming our new data and the data they come from\npenguins_simp <- penguins %>%\n  # Now group by species and island\n  dplyr::group_by(species, island) %>%\n  # Calculate average bill length\n  dplyr::summarize(avg_bill_length_mm = mean(bill_length_mm, na.rm = TRUE)) %>%\n  # And don't forget to ungroup!\n  dplyr::ungroup()\n\n# And this is what we're left with:\npenguins_simp\n\n# A tibble: 5 × 3\n  species   island    avg_bill_length_mm\n  <fct>     <fct>                  <dbl>\n1 Adelie    Biscoe                  39.0\n2 Adelie    Dream                   38.5\n3 Adelie    Torgersen               39.0\n4 Chinstrap Dream                   48.8\n5 Gentoo    Biscoe                  47.5\n\n\nGreat! We can use this smaller data object to demonstrate reshaping more clearly."
  },
  {
    "objectID": "reshape.html#reshaping-data",
    "href": "reshape.html#reshaping-data",
    "title": "Reshape",
    "section": "Reshaping Data",
    "text": "Reshaping Data\n\nExample: Reshaping Wider\nLet’s begin with pivot_wider. Let’s say that we want to take that data object and reshape it into wide format so that each island is a column and each species of penguin is a row. The contents of each cell then are going to be the average bill length values that we just calculated.\n\n\n# Begin by naming the objects\npenguins_wide <- penguins_simp %>%\n  # And now we can pivot wider with `pivot_wider`!\n  tidyr::pivot_wider(\n    names_from = island,\n    values_from = avg_bill_length_mm )\n\n# Take a look!\npenguins_wide\n\n# A tibble: 3 × 4\n  species   Biscoe Dream Torgersen\n  <fct>      <dbl> <dbl>     <dbl>\n1 Adelie      39.0  38.5      39.0\n2 Chinstrap   NA    48.8      NA  \n3 Gentoo      47.5  NA        NA  \n\n\nGreat! We now have each island as a column, each row is a penguin species, and the bill length measurement we took is included in each cell. Note that in this specific case this makes the number somewhat ambiguous so we might want to use dplyr’s select or the more specific rename to change the island names to be clearer that those values are bill lengths in milimeters.\n\n\nExample: Reshaping Longer\nNow that we have a small wide format data object, we can feed it to pivot_longer and reshape our data into long format! pivot_longer has very similar syntax except that with pivot_longer you need to tell the function which columns should be reshaped.\npivot_wider on the other hand knows which columns to move around because you manually specify them in the “names_from” and “values_from” arguments.\n\n\n# Begin with our wide data\npenguins_wide %>%\n  # And reshape back into long format\n  pivot_longer(\n    cols = -species,\n    names_to = \"island_name\",\n    values_to = \"mean_bill_length_mm\" )\n\n# A tibble: 9 × 3\n  species   island_name mean_bill_length_mm\n  <fct>     <chr>                     <dbl>\n1 Adelie    Biscoe                     39.0\n2 Adelie    Dream                      38.5\n3 Adelie    Torgersen                  39.0\n4 Chinstrap Biscoe                     NA  \n5 Chinstrap Dream                      48.8\n6 Chinstrap Torgersen                  NA  \n7 Gentoo    Biscoe                     47.5\n8 Gentoo    Dream                      NA  \n9 Gentoo    Torgersen                  NA  \n\n\nTwo quick things to note here:\n\nFirst, pivot_longer included the cells that were NA in the wide version of the data.\n\nThis default behavior is really nice so that you don’t lose any cells implicitly (though you can always filter them out if you don’t want them!).\n\nSecond, you’ll note that in the “cols” argument I only told pivot_longer to not include the “species” column using the same notation you could use for the select function in the dplyr package.\n\nThis is very handy because it lets us write really concise values in the “cols” argument and the default becomes “everything except what was specified”.\nNote that we could have also said cols = Biscoe, Dream, Torgersen and achieved the same reshaping of the data.\n\n\n\n\nChallenge: Reshaping\nThe code below creates a data object that includes the flipper length of all Adelie penguins; what code would you add to reshape the data so that each sex is a column with flipper lengths in the cells?\n\npenguins %>%\n  # Keep only Adelie penguins of known sex\n  dplyr::filter(species == \"Adelie\" & !is.na(sex)) %>%\n  # Calculate the average flipper length by island and sex\n  dplyr::group_by(island, sex) %>%\n  dplyr::summarize(avg_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE)) %>%\n  # Ungroup (good practice to include this step!)\n  dplyr::ungroup()\n\n# A tibble: 6 × 3\n  island    sex    avg_flipper_length_mm\n  <fct>     <fct>                  <dbl>\n1 Biscoe    female                  187.\n2 Biscoe    male                    190.\n3 Dream     female                  188.\n4 Dream     male                    192.\n5 Torgersen female                  188.\n6 Torgersen male                    195."
  }
]